# 缓存过期和内存淘汰

## 缓存过期
### redis是怎么删除过期key的?
Redis删除过期key采用了三种策略的混合：惰性删除、定期删除和主动删除。
这种混合策略在内存占用和CPU使用之间取得了良好平衡。

#### 惰性删除
只在必要时删除，不浪费CPU资源
缺点：
如果大量key过期但未被访问，会占用大量内存,严重会导致内存泄漏

#### 定期删除
Redis维护一个定时任务，周期性地抽样检查一部分过期key并删除它们。
##### 执行策略
默认每100ms执行一次过期检查,每次检查会依次扫描所有数据库.
每个数据库中随机抽取20个带过期时间的key,删除其中已过期的key.
如果某个库中过期key比例超过25%，则重复步骤3-4，直到过期key比例低于25%或达到时间上限.
优点:
通过控制删除频率和时间，平衡CPU和内存占用,避免长时间阻塞服务
缺点:
难以确定最佳采样率和执行频率,然后也可能有部分过期key未被及时删除
#### 主动删除
Redis还在特定场景下主动删除过期key：
- 写时删除
当执行写操作(如SET)时，如果目标key已过期，Redis会先删除它再执行写入。
- 从库同步删除
当主库因key过期而删除时，会向从库发送DEL命令，确保主从一致性。
- RDB加载过滤
在RDB加载过程中，Redis会过滤掉过期的key，避免将它们写入新的RDB文件。
- AOF重写过滤
执行AOF重写时，不会将已过期的key写入新的AOF文件。

### 应用场景
根据这个特点可以设置一些缓存策略:
- 热点数据(如考试配置)设置较长过期时间
- 临时数据(如验证码)设置短期过期时间

## 内存淘汰
Redis提供了8种内存淘汰策略，可以分为三大类：
- 不淘汰：noeviction策略，内存不足时拒绝写入
- 针对设置了过期时间的键：volatile系列，包括：
  - volatile-lru：淘汰最久未使用的
  - volatile-lfu：淘汰使用频率最低的
  - volatile-ttl：淘汰剩余生存时间最短的
  - volatile-random：随机淘汰
- 针对所有键：allkeys系列，包括：
  - allkeys-lru：淘汰最久未使用的
  - allkeys-lfu：淘汰使用频率最低的
  - allkeys-random：随机淘汰

### 应用场景
根据经验来看，选择合适的内存淘汰策略应考虑：
- 数据重要性：核心业务数据考虑noeviction，防止意外丢失
- 访问模式：
  - 明显热点数据选择LFU系列
  - 时间局部性强选择LRU系列
  - 时效性数据选择TTL系列
- 过期时间设置：如果所有键都设置了合理的过期时间，volatile系列通常足够


# 个人回答版
第一类是不淘汰策略，即noeviction，当内存不足时直接拒绝写入操作。这适用于对数据完整性要求极高的场景。
第二类是针对设置了过期时间的键进行淘汰的volatile系列策略。这类策略只会淘汰设置了过期时间的键.
第三类是针对所有键的allkeys系列策略，不管键是否设置了过期时间都可能被淘汰。
第二类和第三类都可以根据lru,lfu,random进行淘汰,第二类还可以根据ttl去淘汰.
在选择策略时，我主要考虑三个因素：数据重要性、访问模式和过期时间设置。
比如，对于有明显热点数据的应用，我会选择LFU系列；
而对于访问模式随时间变化的应用，LRU系列更合适。

### 记忆口诀
> "全域随近少，过期随近少时，拒绝不淘汰"
- 全域：allkeys系列（针对所有键）
- 随近少：random(随机)、LRU(最近)、LFU(最少)
- 过期：volatile系列（针对过期键）
- 随近少时：random、LRU、LFU、TTL(时间)
- 拒绝不淘汰：noeviction


## 内存回收是什么时候发起的
内存回收有两种机制: 过期键删除和内存淘汰.
他们触发时机有一些差距.
过期键删除触发时机有两个:
- 惰性删除当访问一个键时
- 定时删除在事件循环中,默认没100ms一次.
内存淘汰触发时机:
- 主要是写命令执行前.
- 还有一些其他触发点:比如AOF重写,RDB保存等可能也会触发


## 介绍一下Redis的LRU回收算法
### 经典LRU算法与Redis实现的差异
传统的LRU(Least Recently Used)算法通常使用双向链表+哈希表实现：
- 访问一个元素时，将其移到链表头部
- 需要淘汰时，移除链表尾部元素
- 哈希表用于O(1)时间定位元素
然而，Redis并没有采用这种标准实现，而是使用了一种近似LRU算法。这是因为：
- 标准LRU需要额外的链表指针，增加内存开销
- Redis已有的数据结构难以支持高效的链表移动操作
- 完美LRU在实际应用中并非必要

 ### Redis为什么不使用标准LRU算法
#### 内存开销分析
标准LRU算法需要维护一个双向链表，每个缓存对象都需要额外的前向和后向指针：
在64位系统上，每个指针占用8字节
一个对象需要两个指针(前向和后向)，共16字节
Redis中存储了数亿级别的键值对时，这些指针会占用大量内存
具体计算：
假设Redis存储1亿个键，标准LRU需要额外的内存：
1亿 × 16字节 ≈ 1.6GB 仅用于LRU链表指针(1个亿是10亿字节)
Redis的核心设计理念之一是高效利用内存,在这种设计理念下，为LRU额外增加16字节/键的开销被认为是不可接受的

#### Redis已有的数据结构难以支持高效的链表移动操作
Redis使用字典(dict)作为主要的数据结构来存储键值对：
- 哈希表的设计目标是快速查找，而非支持排序或顺序访问
- 哈希表中的元素位置由哈希函数决定，不便于维护访问顺序

#### 完美LRU在实际应用中并非必要
近似LRU算法在实际应用中表现良好,采样数为10时，近似LRU的效果已接近理论LRU的99%.




### Redis的近似LRU算法实现
Redis的LRU算法基于随机采样：
1. 从键空间随机选择n个键(由maxmemory-samples配置，默认为5)
2. 比较这n个键的最后访问时间
3. 淘汰其中最久未使用的键

```c
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:24;  // LRU时间戳或LFU数据
    int refcount;
    void *ptr;
} robj;
```
这个时间戳记录了对象最后被访问的时间，精度为分钟级别。


#### 采样数量与精度的关系
maxmemory-samples参数直接影响LRU的精度:
- 默认值为5，是性能和精度的平衡点
- 增加到10可以使近似LRU非常接近理论LRU(约99%的精度)
- 但更高的采样数会增加CPU开销

Redis作者antirez的测试表明：
- 采样数=5时，近似LRU的命中率约为93%的理论LRU
- 采样数=10时，近似LRU的命中率约为99%的理论LRU

实际应用中的优化:
这就给了我们一些操作空间,我们可以根据不同场景去调整了LRU参数：
- 高流量缓存服务：
  - 增加采样数到10，提高LRU精度
  - 适用于内存有限但对性能要求不是极端的场景(因为CPU开销会增大)
- 读多写少的数据：
  - 保持默认采样数5
  - 在大多数缓存场景下表现良好



#### 时间戳更新机制
Redis不会在每次访问对象时都更新LRU时钟，而是采用一种概率更新策略：
- 默认情况下，每个对象被访问时有1/10的概率更新时间戳
- 这种策略减少了写操作，提高了性能
- 对LRU精度影响有限，因为分钟级精度已足够淘汰决策

#### 近似LRU的缺点
比较容易导致缓存污染,Redis2.8版本之前,Redis 2.8的LRU在采样数=5时，命中率仅约35%. 
缓存污染的严重程度 - 有大量应该保留的热点数据被错误淘汰，而冷数据却占据了缓存空间。
我觉得主要因为:
- 完全随机采样，某些很久未被访问的键可能因为"运气好"而长期不被选中淘汰,假设有100万个键，但每次只采样5个
某个已经1个月未访问的"冷数据"，被选中的概率只有5/1,000,000
这个"幸运键"可能连续数千次淘汰过程都不被选中
同时，一些刚刚被访问过但"不幸"被选中的热点数据可能被淘汰,缓存中会积累大量实际上已经"冷"但侥幸存活的数据，这正是典型的缓存污染。
- 单次采样决策导致淘汰决策存在较大随机性：每次淘汰都是独立的,这种偏差会随着时间累积,使得缓存中"应该被淘汰"的键比例越来越高.

#### Redis 3.0后的LRU改进
Redis 3.0对LRU算法进行了显著改进：
引入了一个淘汰池(`eviction pool`)，保存候选淘汰对象
采样过程更加智能，不仅考虑当前采样结果，还参考之前的采样
淘汰池按空闲时间排序，优先淘汰空闲时间最长的对象
这些改进使得Redis的近似LRU更接近理论LRU，即使在较小的采样值下也有良好表现。


##### 优先淘汰最冷数据策略
缓存系统中,"冷数据"指的是长时间未被访问或访问频率极低的数据,具体来说:
时间维度：长时间未被访问的数据（LRU角度）
频率维度：访问次数少的数据（LFU角度）
Redis的LRU实现主要关注时间维度，通过记录键的最后访问时间来判断数据的"冷热程度"。

我当时比较好奇它是怎么识别和淘汰最冷数据的.

##### Redis如何识别和淘汰最冷数据
 1. 计算空闲时间,空闲时间越长，表示数据越"冷"，越应该被优先淘汰。
 2. 引入的淘汰池按照空闲时间对键进行排序，这是"优先淘汰最冷数据"策略的核心
 3. 在evictionPoolPopulate方法中,拿到了空闲时间,有一个while循环,会按空闲时间进行降序排列
 4. 池头部是最冷的数据,尾部是最热的数据
 5. 选择淘汰池中的第一个键, 从数据库中删除该键,从淘汰池中移除该条目,直到内存足够.

有了这次更新,我们能够在有限的内存资源下，最大化缓存的效益，同时保持系统的高性能和稳定性。


# 个人回答版
传统的LRU(Least Recently Used)算法通常使用双向链表+哈希表实现：
- 访问一个元素时，将其移到链表头部
- 需要淘汰时，移除链表尾部元素
- 哈希表用于O(1)时间定位元素


然而，Redis并没有采用这种标准实现，而是使用了一种近似LRU算法。
这是因为：
- 标准LRU需要额外的链表指针，增加内存开销
- Redis已有的数据结构难以支持高效的链表移动操作
- 完美LRU在实际应用中并非必要

当然,Redis3.0前这种近似的LRU算法并不好用,但是它有一个算法演进:
- Redis 3.0前：简单随机采样，精度有限（采样数5时仅35%左右）
- Redis 3.0后：引入淘汰池，大幅提升精度（采样数5时达93%，采样数10时达99%）

这个采样数直接影响算法精确度,我们可以灵活配置它.
时间戳的更新策略也会小小的影响精确度,但一般无关紧要.


## 什么是LFU算法,为什么Redis要引入LFU算法
LFU(Least Frequently Used)算法是一种缓存淘汰策略，它基于使用频率来决定淘汰哪些数据。
核心思想是：淘汰访问次数最少的数据项。

### 基本原理
为每个缓存项维护一个访问频率计数器,每当数据被访问时，增加其计数器值,需要淘汰时，移除计数器值最小的数据项.

### 为什么引入LFU算法
LRU算法存在一个根本性缺陷：它只考虑时间因素，忽略了访问频率。
这导致以下问题:
- 突发访问问题
假如一个每5分钟访问一次的重要键是A，和一个突然被访问100次但再也不会被访问的键是B。
LRU会淘汰重要的键A而保留不再需要的键B.
这显然不合理，因为A是稳定的热点数据，而B只是临时热点。
- 不能适应更复杂的访问模式
  - 现代应用的数据访问模式越来越复杂：
    - 长尾分布：少量数据被频繁访问，大量数据被偶尔访问
    - 突发访问：数据短时间内被大量访问，然后长时间不再访问
    - 周期性访问：数据按固定时间间隔被访问
### 如何实现LFU
实现非常巧妙，它重用了原有的24位LRU字段，将其分为两部分：
-上次递减时间(Last Decr)：用于实现计数器的衰减,防止历史热点永远占据缓存;16位
-计数器(Counter)：记录访问频率，计数器不是线性增加的，而是概率递增，递增概率随着计数值增大而减小;8位，最大值255

 16 bits      8 bits
+------------+--------+
| Last Decr  | Counter |
+------------+--------+


### 局限性
尽管LFU有诸多优势，但它也有一些局限性：
1. 冷启动问题：新加入的数据初始频率为0，需要时间积累才能与老数据竞争
2. 内存开销：需要为每个键维护额外的计数器(不过Redis通过复用LRU字段巧妙解决了这个问题)
3. 参数调优：LFU的效果受lfu-log-factor和lfu-decay-time参数影响，需要根据实际工作负载调优.




### 如何选择LRU还是LFU
Redis提供了LRU和LFU两种策略，如何选择取决于您的应用场景：
适合使用LRU的场景
- 访问模式具有强时间局部性
- 最近访问的数据很可能再次被访问
- 所有数据的重要性相近
适合使用LFU的场景
- 访问频率差异明显
- 有明确的数据访问偏好
- 存在周期性访问的重要数据
- 需要区分临时热点和持久热点







