# 跳表

## 跳表的定义
跳表(Skip List)是一种随机化的数据结构，本质上是对有序链表的优化，通过维护多层索引来加速查找过程。
是一种可以替代平衡树（如红黑树）的数据结构，在Redis中被用于实现有序集合（Sorted Set）.

## 跳表的特点
1. 多层结构:    
- 最底层是一个完整的有序链表，包含所有元素
- 上层是索引层，每一层都是下一层的"快速通道"
- 层数越高，元素越少，查找速度越快
2. 随机化特性
- 元素插入时通过随机函数决定其索引层数
- 通常第 i 层的节点数约为第 i-1 层的 1/2 或 1/4
3. 有序性
- 所有节点按照关键字排序




## 跳表的结构
```c
typedef struct zskiplist {

    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;

    // 表中节点的数量
    unsigned long length;

    // 表中层数最大的节点的层数
    int level;

} zskiplist;
```

```c
typedef struct zskiplistNode {
    // 后退指针
    struct zskiplistNode *backward;
    // 分值
    double score;
    // 成员对象
    robj *obj;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
```
跳表由以下部分组成：
1. 多层索引结构：
    - 最底层（Level 0）是一个包含所有元素的双向有序链表
    - 上层是下层的"快速通道"，节点数量随层数上升而递减
    - 通常第 i 层的节点数约为第 i-1 层的 1/2 或 1/4
2. 节点类型：
    - 头节点：特殊节点，不存储实际数据，包含最大层数的前向指针
    - 上层节点：是一个单向链表，只需要支持快速向前查找,层数随机生成
    - 底层节点: 是一个双向链表,有丰富的操作.
3. 随机化层数：
    - 新节点插入时通过随机函数决定其层数(随机函数决定是节点在哪一层)
    - 层数生成算法类似抛硬币：50%概率为1层，25%概率为2层，12.5%概率为3层...


### 跳表层级指针结构
在典型的跳表实现中，最底层是一个完整的双向链表，包含所有元素，并有前向和后向指针支持双向遍历。
而上层索引通常只实现为单向链表，只包含前向指针。
这样设计的原因是：上层索引主要用于加速查找过程，查找总是从头节点开始向后遍历；而范围查询和反向遍历只需要在底层进行。这种设计在保持跳表功能完整的同时，减少了内存开销和实现复杂度

## 跳表的查询过程
1. 从最高层的头节点开始，在当前层向右遍历，直到找到大于目标值的节点.
2. 然后转入下一层继续遍历，直到到达最底层.
3. 最终在最底层找到目标节点或确定其不存在.



## 性能优化类题目
###  跳表的随机层数生成对性能有什么影响？如何优化？
影响:
- 层数过少: 退化为链表，查询性能下降
- 层数过多: 空间浪费，插入删除开销增大
- 分布不均: 可能导致查询路径不平衡

优化:
- 调整概率参数(p)，典型值为1/2或1/4
- 限制最大层数，通常为log₁/ₚ(N)或更小
- 考虑确定性替代方案，如每2^i个节点提升到第i层
- 动态调整层数生成策略，根据实际数据分布


###  跳表与红黑树在实际应用中的性能对比分析
- 时间复杂度对比:
    - 两者平均查找/插入/删除都是O(log n)
    - 跳表常数因子通常更小，实际速度可能更快
- 内存使用:
    - 跳表平均每个节点1.33个指针(p=1/4时)
    - 红黑树每个节点固定3个指针(左、右、父)
    - 跳表内存布局更连续，缓存友好
- 实现复杂度:
    - 跳表实现简单，约100行代码
    - 红黑树实现复杂，约500行代码
- 并发性能:
    - 跳表更适合并发环境，局部修改不影响整体
    - 红黑树旋转操作影响范围大，并发控制复杂


## 应用与扩展类
### 如何使用跳表实现LRU缓存？
1. 使用跳表存储缓存项，按访问时间排序.
2. 每次访问时:
    - 删除原位置的节点
    - 插入到跳表头部(最新位置)
    - 缓存满时，删除跳表尾部(最旧)节点
3. 优势:
    - O(log n)的查找、插入、删除
    - 天然支持按时间顺序访问
    - 实现简单，无需复杂的平衡操作


### 跳表如何支持范围查询？与B+树相比有何优劣？
1. 跳表范围查询实现:
    - 使用查找算法定位范围起点
    - 在底层链表中顺序遍历直到范围终点
    - 时间复杂度: O(log n + k)，k为范围内元素数
2. 与B+树对比:
    - 优势:
        - 实现更简单
        - 内存环境中更高效
        - 更新操作更轻量，不需要分裂合并
    - 劣势:
        - 不如B+树适合磁盘存储(IO次数更多)
        - 空间利用率可能较低
        - 缓存局部性不如B+树








