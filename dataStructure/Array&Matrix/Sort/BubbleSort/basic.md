# 冒泡排序

## 学习路线与直觉

- **核心直觉**: 冒泡排序每一轮把“当前最大值”通过相邻交换“冒”到右端。重复多轮，直到整体有序。
- **关键性质**:
  - **稳定**: 相等元素相对次序不变（用 `>` 而不是 `>=` 比较）
  - **原地**: 只用常数额外空间
  - **时间复杂度**: 最坏/平均 O(n^2)，最好 O(n)（有“提前终止”优化时）
  - **适用场景**: 教学、近乎有序的小数组；工业场景一般不用它做大规模排序

## 基本流程（升序）

1. 外层第 i 轮：范围 [0, n-1-i] 未有序
2. 内层指针 j：比较并交换 `a[j]` 与 `a[j+1]`，把本轮最大值推到末尾
3. 重复到只剩 1 个元素

## Java 实现：基础版

```java
public static void bubbleSort(int[] nums) {
    if (nums == null || nums.length <= 1) return;

    int n = nums.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (nums[j] > nums[j + 1]) {
                int tmp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = tmp;
            }
        }
    }
}
```

## 优化一：提前终止（近乎有序更快）

```java
public static void bubbleSortEarlyExit(int[] nums) {
    if (nums == null || nums.length <= 1) return;

    int n = nums.length;
    for (int i = 0; i < n - 1; i++) {
        boolean swapped = false;
        for (int j = 0; j < n - 1 - i; j++) {
            if (nums[j] > nums[j + 1]) {
                int tmp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = tmp;
                swapped = true;
            }
        }
        if (!swapped) break; // 本轮无交换，数组已完全有序
    }
}
```

## 优化二：缩小边界（利用最后交换位置）

- 思想：最后一次交换位置右侧已是有序区，下轮只需冒到该位置即可。

```java
public static void bubbleSortWithBoundary(int[] nums) {
    if (nums == null || nums.length <= 1) return;

    int last = nums.length - 1;
    while (last > 0) {
        int newLast = 0; // 本轮最后交换位置
        for (int j = 0; j < last; j++) {
            if (nums[j] > nums[j + 1]) {
                int tmp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = tmp;
                newLast = j;
            }
        }
        last = newLast; // 下一轮只需冒到 newLast
        if (newLast == 0) break; // 无交换或交换都在0位置，提早结束
    }
}
```

## 变体：鸡尾酒排序（双向冒泡，减少偏序链路长距离位移）

```java
public static void cocktailShakerSort(int[] nums) {
    if (nums == null || nums.length <= 1) return;

    int start = 0, end = nums.length - 1;
    while (start < end) {
        boolean swapped = false;
        // 从左到右，最大值右移到 end
        for (int j = start; j < end; j++) {
            if (nums[j] > nums[j + 1]) {
                int tmp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = tmp;
                swapped = true;
            }
        }
        end--;
        // 从右到左，最小值左移到 start
        for (int j = end; j > start; j--) {
            if (nums[j - 1] > nums[j]) {
                int tmp = nums[j - 1];
                nums[j - 1] = nums[j];
                nums[j] = tmp;
                swapped = true;
            }
        }
        start++;
        if (!swapped) break;
    }
}
```

## 手推示例（[5, 1, 4, 2, 8]，基础版第一轮）

- 比较 5 和 1 → 交换：[1, 5, 4, 2, 8]
- 比较 5 和 4 → 交换：[1, 4, 5, 2, 8]
- 比较 5 和 2 → 交换：[1, 4, 2, 5, 8]
- 比较 5 和 8 → 不换：[1, 4, 2, 5, 8]（本轮最大 8 已就位）

## 常见错误

- 使用 `>=` 导致不稳定；正确是用 `>` 比较
- 内层上界写错，应到 `n - 1 - i` 或 `last`
- 忘记空数组/单元素的快速返回
- 提前终止标志位 `swapped` 未正确重置

## 练习与巩固

- 实现三版：基础版、提前终止版、边界缩小版，并写基准测试比较近乎有序与逆序输入的用时
- 输出每一轮数组状态，加深“最大值右移、范围缩小”的直觉
- 改写为降序（只需改比较符为 `<`）
- 扩展：对 `List<Integer>` 实现、或对 `Comparable<T>` 泛型实现

## 何时用/不用

- 用：教学、数据量很小或几乎有序、需要稳定性且实现成本要极低
- 不用：中大规模数据；优先选择归并/快速/堆排序或库排序

## 小结

- 记住三件事：相邻交换、每轮最大值就位、范围逐轮缩小
- 两个实用优化：提前终止、边界缩小
- 稳定、原地；最好 O(n)，最坏/平均 O(n^2)


## 为什么会有多个版本（动机与本质）

- **基础版**：教学用的朴素实现。每一轮把当前最大值“冒”到末尾，但会做很多不必要的比较。
- **提前终止版（Early Exit）**：如果某一轮没有发生交换，说明数组已经有序，直接停止，避免“多余轮次”。
- **边界缩小版（最后交换位置）**：记录本轮“最后一次交换”的位置，右侧天然有序；下一轮只需冒到这个位置，减少“多余比较”。
- **鸡尾酒排序（双向冒泡）**：针对“小值卡在右端”的情况，单向冒泡需要多轮左移；双向一轮把最大值右移、最小值左移，加速两端就位。

这些版本不是在“改变算法”，而是在用更准的“有序信号”减少不必要的比较/轮次：从“完全不知道哪儿有序”（基础版）→“知道整体已有序能停”（早停）→“知道有序边界在哪里”（边界缩小）→“知道两端都需要推进”（鸡尾酒）。

---

## 各版本精要与适用场景

- **基础版**
  - 机制：固定做 n−1 轮，内层比较到 n−1−i。
  - 复杂度：平均/最坏 O(n^2)，最好 O(n^2)。
  - 用途：入门讲解；理解“最大值沉底”的循环不变式。

```java
for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - 1 - i; j++) {
        if (a[j] > a[j + 1]) swap(a, j, j + 1);
    }
}
```

- **提前终止版（近乎有序明显更快）**
  - 机制：一轮无交换即结束。
  - 复杂度：最好 O(n)（已排序或近乎有序时），平均/最坏 O(n^2)。
  - 何时优：数据基本有序、每轮早停很常见。

```java
for (int i = 0; i < n - 1; i++) {
    boolean swapped = false;
    for (int j = 0; j < n - 1 - i; j++) {
        if (a[j] > a[j + 1]) { swap(a, j, j + 1); swapped = true; }
    }
    if (!swapped) break;
}
```

- **边界缩小版（比较次数更少）**
  - 机制：记录本轮“最后交换位置”newLast；下轮只比较到 newLast。
  - 复杂度：平均/最坏仍 O(n^2)，但常数因子更小；最好 O(n)。
  - 何时优：部分后缀早早有序，早停无法利用“有序尾巴”的长度，但边界缩小可以。

```java
int last = n - 1;
while (last > 0) {
    int newLast = 0;
    for (int j = 0; j < last; j++) {
        if (a[j] > a[j + 1]) { swap(a, j, j + 1); newLast = j; }
    }
    if (newLast == 0) break;
    last = newLast;
}
```

- **鸡尾酒排序（双向推进，缩短位移路径）**
  - 机制：一轮从左到右把最大值放到右端，再从右到左把最小值放到左端。
  - 复杂度：平均/最坏 O(n^2)，最好 O(n)。
  - 何时优：极端“锯齿/双峰/小值在右、大值在左”的分布，单向冒泡移动距离长，双向更合适。

```java
int start = 0, end = n - 1;
while (start < end) {
    boolean swapped = false;
    for (int j = start; j < end; j++) if (a[j] > a[j + 1]) { swap(a, j, j + 1); swapped = true; }
    end--;
    for (int j = end; j > start; j--) if (a[j - 1] > a[j]) { swap(a, j - 1, j); swapped = true; }
    start++;
    if (!swapped) break;
}
```

---

## 复杂度与性质对比（面试高频）

- **时间复杂度**：
  - 基础：最好/平均/最坏都是 O(n^2)
  - 早停/边界缩小/鸡尾酒：最好 O(n)，平均/最坏 O(n^2)
- **空间复杂度**：均为 O(1) 原地
- **稳定性**：均可稳定（比较用 `>` 而非 `>=`）
- **适用性**：教学、小规模或近乎有序；工程上大规模排序更偏向归并/快排/堆/TimSort（库排序）

---

## 面试官可能怎么问（以及想考什么）

- **写出基础版并解释循环不变式**
  - 考察：基本功、正确性表达（“第 i 轮后，后缀长度 i 的部分有序且为当前最大 i 个元素”）
- **如何优化？为何有效？复杂度变化？**
  - 考察：工程意识（早停/边界）、数据分布对性能的影响（最好 O(n) 的来源）
- **稳定吗？如何保证稳定？**
  - 考察：排序稳定性的定义与对比较条件的把控（`>` vs `>=`）
- **与插入排序/选择排序对比？**
  - 考察：近乎有序时插入/冒泡表现都好；选择排序固定 O(n^2) 且通常不稳定，但交换少
- **举例触发最好/最坏情况**
  - 最好：已升序
  - 最坏：严格降序（或“每次都交换”的构造）
- **什么时候用鸡尾酒排序？**
  - 考察：对数据模式的敏感度（双向减少远距离搬移）

---

## 常见陷阱

- 用了 `>=` 破坏稳定性
- 内层边界写成 `j < n - i` 而不是 `j < n - 1 - i`
- 忘记重置 `swapped` 或者未正确更新 `newLast`
- 只做了早停，但数据“后缀已完全有序”仍在做无意义比较 → 可以考虑边界缩小

---

## 如何在项目里“学会又用好”

- 先写基础版，打印每轮结果，培养“最大值沉底、范围缩小”的直觉
- 加“早停”，用“已排序/近乎有序/随机/逆序”四类数据做小基准，感受最好 O(n)
- 加“边界缩小”，观察比较次数明显减少（可以计数比较次数）
- 准备 1-2 分钟口述版本，面试时能快速阐述“优化思路与适用场景”

---

## 一句话记忆

- 相邻交换，最大值沉底；用“无交换”和“最后交换位置”判定边界；极端分布用双向。

## 关键区别：固定缩小 vs 自适应缩小

- 基础版的上界 `j < n - 1 - i` 是“按轮数固定缩小”：每一轮只少比较 1 个位置，不关心这一轮里实际发生的交换在哪里。
- 边界缩小版用“最后交换位置” `newLast`：用本轮的真实有序边界作为下一轮的上界。若后缀早就有序，下一轮会一下子少比较很多，而不是只少 1 个。

## 一个反例就看懂差异

数组：`[1, 2, 3, 4, 5, 0, 6, 7, 8, 9]`（长后缀已排好，只是 0 卡在中间）

- 基础版（固定 `n-1-i`）：
  - 比较次数固定是 9 + 8 + 7 + ... + 1 = 45（不管数据长什么样）
- 边界缩小版（记录 `newLast`）：
  - 第 1 轮：比较 9 次，最后交换发生在 j=4 → `last = 4`
  - 第 2 轮：只比较到 j=3（4 次），又把 0 左移一格 → `last = 3`
  - 之后比较 3 + 2 + 1
  - 总比较：9 + 4 + 3 + 2 + 1 = 19（显著少于 45）

结论：两者“都在缩边界”，但基础版是“按回合数恒定缩小 1”，边界缩小版是“按数据真实无序范围自适应缩小，能一下子缩很多”。

## 什么时候两者看起来“没区别”

- 最坏情况（严格降序）或数据非常乱时，每轮的最后交换位置通常就在靠右的位置，`newLast` 基本等于 `n-1-i`，两者表现接近。
- 最好情况（完全有序）：若没有“提前终止”优化，基础版仍做满所有比较；边界缩小版会因为 `newLast` 始终为 0 而直接退出，达到 O(n)。

实际最优实现通常把“两点”合在一起：

- 有“提前终止”（本轮无交换就停）
- 再加“边界缩小”（利用最后交换位置）

## 面试会不会问？在考察什么？

- 会问的频率不低，尤其在“基础排序 + 工程意识”环节。
- 常见追问与考点：
  - 为什么 `n-1-i` 不够好？（固定缩减 vs 自适应缩减的本质差异）
  - 举一个“长后缀已排序”的例子，说明边界缩小的收益（能否给出比较次数级别的量化）
  - 提前终止与边界缩小分别解决什么问题（整体已序 vs 局部后缀已序）
  - 最好/最坏/平均复杂度、稳定性如何保证（用 `>` 而非 `>=`）
  - 与插入排序/选择排序对比（近乎有序时插入/冒泡更好；选择交换少但通常不稳定）

## 小结（一句话）

- `n-1-i` 是“每轮固定少 1”，边界缩小是“根据最后交换位置自适应少很多”；当存在大段已排序后缀或局部小乱序时，边界缩小节省大量比较。