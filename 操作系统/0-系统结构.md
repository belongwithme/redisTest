# 存储结构
## 为什么计算机要给存储结构分级？
计算机存储结构分级主要是为了平衡速度和容量的矛盾。越靠近CPU的存储越快但容量小且成本高,越远离CPU的存储容量大但速度慢。通过分级存储,可以在性能和成本之间取得平衡,利用局部性原理(时间局部性和空间局部性)提高系统整体性能。
个人理解版:
存储分级是计算机系统的必然选择。如果只用最快的存储介质,成本会高到无法承受,而且容量也不够大;如果只用大容量存储,系统性能会非常差。分级存储利用了程序访问的局部性特点,将最常用的数据放在高速缓存中,构建了一个性能、容量、成本三者平衡的系统。
实际上,这就像我们的生活习惯:常用物品放在手边,不常用的放在柜子深处,这是处理信息的自然规律。
## CPU cache L1 L2 L3 读取数据的时间量级差距有多大？
现代CPU缓存层次的访问延迟大致为:
- L1 缓存: 约1-5纳秒
- L2 缓存: 约7-20纳秒
- L3 缓存: 约20-75纳秒
- 主内存(RAM): 约100-300纳秒
这表明从L1到L3再到内存,访问延迟大约有几十倍的差距。
## CPU 缓存对程序性能的影响和优化的一些方面？
CPU缓存对性能影响体现在:
1. 缓存命中率直接影响程序执行速度
2. 缓存行(Cache Line)是缓存管理的基本单位,通常为64字节
3. 缓存一致性协议在多核环境下保证数据一致性,但可能带来性能开销
优化方面:
1. 数据结构布局优化,使相关数据在内存中连续
2. 避免伪共享(False Sharing)
3. 预取技术(Prefetching)
4. 循环展开和分块(Loop Unrolling and Blocking)
5. 数据对齐(Data Alignment)
# 内核态（重要）
## 什么是内核？
内核是操作系统的核心组件，是连接应用程序和硬件的桥梁。它管理系统的资源（如CPU、内存、I/O设备等），提供基础服务，并为应用程序提供硬件抽象层，使应用程序无需直接与硬件交互。内核通常负责进程管理、内存管理、文件系统管理、设备驱动程序管理和网络管理等功能。
个人理解:
内核就像城市的基础设施和管理系统。
应用程序是城市中的居民，而硬件资源则是水、电、道路等基础资源。
内核维护秩序，确保资源被公平高效地分配，同时保护系统不受恶意程序破坏。
## 内核态和用户态区别？为什么要区分内核态和用户态？
内核态和用户态的区别：
1. 特权级不同：内核态运行在最高特权级（Ring 0），可以执行所有CPU指令，访问所有内存；用户态运行在较低特权级（Ring 3），只能执行非特权指令，访问受限内存。
2. 功能不同：内核态可以直接访问硬件、控制中断、管理内存等；用户态只能通过系统调用请求内核提供的服务。
3. 资源访问：内核态可访问所有系统资源；用户态只能访问被允许的资源。
区分内核态和用户态主要是为了：
1. 系统安全：防止用户程序直接访问和修改关键系统资源。
2. 系统稳定性：隔离用户程序错误，避免影响整个系统。
3. 资源保护：通过内核管理和分配资源，防止单个程序独占系统资源。
4. 硬件抽象：为应用程序提供统一接口，简化应用开发。

个人理解版本:
内核态和用户态的区分就像一个国家的政府和公民关系。内核态拥有"特权"，可以调动一切资源、执行任何操作，而用户态则像普通公民，只能在规定的范围内活动，需要特殊服务时必须通过正规渠道（系统调用）向内核申请。
为什么要这样区分？我理解这是基于安全性和稳定性的考虑。如果所有程序都能直接操作硬件，就像每个人都能随意操作电网或自来水系统，社会将陷入混乱。
## 什么时候会由用户态切换到内核态？
用户态切换到内核态主要发生在以下情况：
1. 系统调用：程序通过系统调用请求内核服务（如文件操作、进程创建等）。
2. 异常：程序执行过程中发生异常（如除零错误、段错误等）。
3. 外部中断：硬件设备发出中断请求（如键盘输入、磁盘完成I/O操作等）。
4. 程序主动触发中断指令：如x86架构的INT指令。

个人理解版:
用户态切换到内核态就像普通人需要政府服务时的流程。主要有三种情况：
1. 首先是主动请求服务，即系统调用。程序需要访问文件、网络或创建新进程时，会通过特定接口（如Linux的syscall）向内核请求服务。这就像我们去政务大厅办理业务。
2. 其次是程序出错，即异常情况。比如程序试图访问不属于它的内存区域，就像公民闯入禁区，系统会立即切换到内核态处理这种违规行为。
3. 最后是外部事件通知，即中断。比如当我们按下键盘，硬件会发出中断信号，CPU暂停当前工作，切换到内核态处理输入。这就像你正在工作，突然有紧急电话需要处理。
## 系统调用的过程？
系统调用的基本过程：
1. 应用程序准备系统调用参数，将参数放入寄存器或栈中。
2. 执行特殊指令（如x86的INT 0x80或SYSCALL），触发从用户态到内核态的切换。
3. CPU保存当前程序状态，切换到内核态。
4. 内核根据系统调用号查找对应的服务例程。
5. 内核执行相应的系统服务，访问硬件或管理资源。
6. 内核将结果放入约定的位置（如特定寄存器）。
7. 恢复用户程序的执行状态，从内核态返回到用户态。
8. 应用程序继续执行，获取系统调用的结果。

个人理解版:
系统调用的过程就像我们通过窗口办理政务服务：
首先，我们填写表格（准备参数）—— 程序将系统调用号和所需参数放入特定位置。
然后，我们按下服务铃（触发陷阱指令）—— 程序执行特殊指令通知CPU需要系统服务。
这时，我们的请求被接收（上下文切换）—— CPU保存当前程序状态，切换到内核态。
接着，服务人员根据表格内容提供服务（内核执行）—— 内核根据系统调用号执行对应功能。
最后，服务完成后我们拿到结果（返回用户态）—— 内核将结果放在约定位置，恢复用户程序执行。
## 用户态和内核态是如何切换的？
用户态和内核态的切换主要涉及以下步骤：
1. 保存用户态上下文：将当前程序的关键寄存器（如程序计数器、栈指针等）保存到内核栈。
2. 特权级切换：CPU将特权级从用户级（Ring 3）切换到内核级（Ring 0）。
3. 栈切换：从用户栈切换到内核栈。
4. 执行内核代码：根据触发切换的原因（系统调用、中断、异常）执行相应的内核处理程序。
5. 恢复用户态上下文：处理完成后，恢复之前保存的用户程序状态。
6. 返回用户态：将特权级从内核级切换回用户级，恢复用户程序执行。
这一过程由硬件（CPU）和操作系统共同完成，以保证切换的安全性和正确性。
个人理解版:
用户态和内核态的切换是一个精密的"交接班"过程：
当需要切换到内核态时，CPU首先会像拍照一样保存当前程序的完整状态（包括所有寄存器值、执行位置等）。这就像你临时离开工作岗位，先记录下自己正在做什么，做到哪一步。
接着，CPU提升自己的权限级别（从Ring 3升至Ring 0），并切换到一个新的工作环境（内核栈）。这就像换上特殊制服，进入管制区域。
在内核态完成必要工作后，再按照之前保存的"照片"，恢复用户程序的所有状态，并降低权限级别回到用户态。
## 为什么用户态切内核态的消耗可切换过程开销比较大？
用户态切换到内核态的开销大主要因为：
1. 上下文保存与恢复：需要保存和恢复大量寄存器和程序状态。
2. TLB刷新：可能需要刷新转换后备缓冲区(TLB)，影响内存访问性能。
3. 缓存影响：切换可能导致CPU缓存失效，需要重新加载数据。
4. 安全检查：系统需要验证参数和权限，确保安全性。
5. 特权指令执行：切换特权级需要执行特殊指令，有额外开销。
6. 地址空间切换：在某些情况下可能需要切换地址空间。
7. 中断禁用：在切换过程中可能需要临时禁用中断，影响系统响应性。
个人理解版:
用户态切换到内核态的开销就像工作中从普通办公区进入高度安全的数据中心：需要重重检查、更换装备、通过多道安全门。
首先是状态保存的开销。CPU必须保存数十个寄存器状态，这就像你临时离开工作岗位需要详细记录每个正在处理的事项。
其次是"装备更换"的开销。系统需要切换栈空间、权限级别，就像更换工作服和安全卡。
还有缓存失效的问题。当切换到内核代码时，CPU缓存中的数据可能不再有用，需要重新加载，这就像换到新工位后需要重新整理工作资料。
在一个性能关键的服务器应用优化过程中，我通过减少不必要的系统调用（例如合并I/O操作，使用内存映射文件），将吞吐量提高了约20%，充分说明了减少这种切换对性能的积极影响。
# 中断
## 什么是中断？为什么要有中断？
中断是一种硬件或软件机制，能暂停当前CPU执行的程序，转而执行一段特定代码（中断处理程序），处理完后再返回原程序继续执行。中断机制主要用于处理异步事件，如I/O完成、定时器到期、异常情况等。
为什么要有中断：
1. 提高CPU利用率：CPU不需要不断轮询外设状态，可以在外设准备好时通过中断通知CPU。
2. 实现异步操作：允许CPU在等待外设操作完成时执行其他任务。
3. 处理异常情况：当程序发生错误时，通过中断机制处理这些异常。
4. 提供及时响应：对于时间敏感的事件能够及时处理。
5. 支持多任务：操作系统利用时间片中断实现多任务切换。
个人理解版:
中断就像生活中的紧急电话或门铃，无论你正在做什么，它都可以打断你当前的工作，让你处理更紧急的事情。
没有中断机制时，系统的工作方式类似于你需要每隔几分钟就去看一下邮箱是否有新邮件，效率极低。有了中断，就像是设置了邮件提醒，新邮件到达会主动通知你。
中断机制是现代计算机系统高效运行的基础,它协调各种设备和事件的处理，让有限的CPU资源能够高效服务于多种任务。
## 什么是硬件中断和软件中断？（基本不同）
硬件中断和软件中断的基本不同：
1. 硬件中断：
- 来源：由外部硬件设备触发，如键盘输入、磁盘完成读写、网卡接收数据等。
- 触发方式：通过中断控制器向CPU发送信号，CPU检测到后响应。
- 优先级：通常硬件中断具有较高优先级，可以打断正常程序执行。
- 处理时机：非同步，随时可能发生，由外部设备决定。
2. 软件中断：
- 来源：由软件指令触发，如系统调用(int 0x80)、异常处理等。
- 触发方式：通过执行特定指令（如x86的INT指令）主动触发。
- 优先级：通常低于硬件中断。
- 处理时机：同步，在指令执行到特定位置时触发。
个人理解版:
硬件中断和软件中断的区别，我喜欢用"门铃和电话预约"来类比：
硬件中断就像家里的门铃 - 它是外部设备（访客）随时可能按响的，你不知道它何时会响，但一旦响了，通常需要放下手头工作去开门。
软件中断则像是预约电话 - 是程序自己安排的，在代码中明确指定"此处需要中断服务"。
比如，程序通过系统调用请求内核服务，就是主动触发的软件中断。
## 为什么要有软中断？（基本不同）
要有软中断的原因：
- 减轻硬中断负担：硬中断处理时通常会屏蔽其他中断，如果处理时间过长，会影响系统响应性。软中断允许将非紧急工作推迟执行。
- 提高系统并发性：软中断可以允许被硬中断打断，也可以在不同CPU上并行执行，提高多核系统性能。
- 平衡延迟和吞吐量：软中断机制为系统提供了一种在低延迟响应和高吞吐量处理之间取得平衡的方法。
- 优先级管理：通过软中断和硬中断的区分，系统可以更灵活地管理任务优先级。
- 简化驱动开发：驱动程序可以将复杂处理推迟到软中断中完成，简化硬中断处理逻辑。
- 改善资源利用：通过推迟非紧急任务的执行，系统可以更高效地利用CPU资源。
个人理解版:
因为硬中断处理时会屏蔽同级中断，导致新到达的数据包无法及时响应。
软中断解决了这个问题：硬中断只负责"接收"数据包并唤醒软中断，然后立即返回；复杂的包处理、协议栈操作则在软中断中完成。这样，系统即使在处理大量数据包时，依然能保持对新中断的响应能力。
另一个关键优势是负载均衡 - 在多核系统中，软中断可以在不同CPU上并行处理，极大提高了系统吞吐量。
将"紧急但简单"的任务与"重要但可延迟"的任务分离，从而在响应速度和处理效率之间取得平衡

# Linux 启动
## 描一下Linux 启动的流程
Linux系统启动流程可分为以下几个主要阶段：
1. BIOS/UEFI阶段：计算机上电后，首先执行BIOS/UEFI固件，进行硬件自检(POST)，然后加载启动设备的引导程序。
2. Bootloader阶段：通常是GRUB2，负责加载内核和初始内存盘(initrd/initramfs)，可以选择不同的内核版本或启动选项。
3. 内核初始化阶段：内核被加载到内存并开始执行，首先解压并自身初始化，然后识别硬件、挂载initramfs临时根文件系统。
4. Init系统阶段：现代Linux发行版一般使用systemd作为init系统（旧系统可能使用SysVinit或Upstart）。systemd作为PID 1进程负责初始化系统环境、启动系统服务。
5. 运行级别/目标单元：根据配置的运行级别（systemd中称为target），系统启动相应服务，如多用户模式或图形界面模式。
6. 用户登录阶段：系统完成启动后，呈现登录界面，等待用户认证后进入系统。
个人理解版
Linux启动过程就像一栋大楼的建造过程，需要有序地搭建从地基到屋顶。
首先是地基工作（BIOS/UEFI）：计算机加电后，BIOS/UEFI就像建筑工地的测量员，检查各项硬件设备是否正常，然后决定从哪个设备开始装载系统。
接着是框架搭建（Bootloader）：GRUB2就像是工地的起重机，负责将沉重的内核代码加载到内存中。它也提供了一个选择菜单，让我们可以选择启动不同版本的内核或其他操作系统。
然后是基础设施建设（内核初始化）：内核就像大楼的钢筋混凝土结构，为整个系统提供支撑。它首先自己"站稳"，然后识别和初始化所有硬件设备，建立起操作系统的核心功能。
再来是内部装修（Init系统）：systemd就像总工程师，按照设计图纸（配置文件）有序地启动各个系统服务。它确保每个服务在正确的时间启动，并解决服务之间的依赖关系。
最后是功能完善（运行级别和服务）：系统会根据预定的目标（比如多用户模式或图形界面）启动相应的服务组件，就像大楼的不同楼层被装修成办公室、会议室等不同功能空间。