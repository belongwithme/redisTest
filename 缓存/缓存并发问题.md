# 缓存并发问题

## 你能解释一下缓存并发问题中的缓存击穿、缓存雪崩和缓存穿透分别是什么吗？
这三个概念是缓存系统中常见的并发问题，它们有明显的区别:
缓存击穿:
缓存击穿是指某个热点key在高并发访问下恰好过期，导致大量并发请求同时穿透缓存直接访问数据库的现象。
这就像一个堤坝上突然出现了一个缺口，所有的水流都从这个点涌入。
关键特征是：单一热点key、高并发、缓存失效。
例如，在电商秒杀活动中，某个热门商品的缓存突然过期，导致上万个并发请求同时查询数据库，可能使数据库瞬间崩溃。
缓存雪崩:
缓存雪崩则是大范围的缓存同时失效，导致海量请求直接冲击数据库的情况。
这就像是雪崩一样，不是一个点而是整面墙同时崩塌。
它通常由以下原因导致：大批缓存同时过期、缓存服务宕机、或Redis主从切换等。
缓存穿透:
缓存穿透是指查询一个根本不存在的数据，因为缓存和数据库都没有该数据，所以每次请求都会穿透缓存直接查询数据库。
这就像是有人不断地在墙上不同位置钻洞。
典型场景是恶意用户持续发起对不存在ID的查询，或者程序bug导致大量无效查询。


## 这三种缓存并发问题各自会带来什么样的系统风险？你能举例说明吗
缓存击穿的风险：
- 数据库突发性能压力：由于热点key通常访问量极大，当它失效时，可能在毫秒级时间内产生成百上千的数据库请求。
- 响应时间剧增：用户请求从毫秒级的缓存访问变为数十或数百毫秒的数据库访问，体验急剧下降。
- 连锁反应：数据库负载增加导致其他查询变慢，可能触发更多超时和重试，形成恶性循环。

缓存雪崩的风险：
- 系统性崩溃：大范围缓存失效导致数据库可能在短时间内接收到成倍于平时的请求量。
- 资源耗尽：数据库连接池、线程池迅速耗尽，导致新请求无法处理。
- 级联故障：一个服务的崩溃可能导致依赖它的其他服务也随之崩溃。
- 恢复时间长：由于影响范围广，系统恢复通常需要较长时间。

缓存穿透的风险：
- 持续性压力：与前两种问题不同，缓存穿透可能是持续性的，而非突发性的。
- 难以察觉：因为每个单独请求看起来并不异常，所以可能在造成严重影响前难以被发现。
- 资源浪费：系统不断处理无效请求，浪费计算和存储资源。
- 安全风险：可能是恶意攻击的手段，如果不加防范，可能被用于DoS攻击。

## 如何解决这三种缓存并发问题？
缓存击穿:
对于批量 key 缓存失效的问题，原因既然是预置的固定过期时间，那解决方案也从这里入手。设计缓存的过期时间时，使用公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间，让数据在未来一段时间内慢慢过期，避免瞬时全部过期.

缓存穿透:
第一种方案就是，查询这些不存在的数据时，第一次查 DB，虽然没查到结果返回 NULL，仍然记录这个 key 到缓存，只是这个 key 对应的 value 是一个特殊设置的值。
但是需要注意.
如果特殊访客持续访问大量的不存在的 key，这些 key 即便只存一个简单的默认值，也会占用大量的缓存空间，导致正常 key 的命中率下降,所以对这些不存在的 key 只存较短的时间，让它们尽快过期.
第二种方案是，构建一个 BloomFilter 缓存过滤器，记录全量数据，这样访问数据时，可以直接通过 BloomFilter 判断这个 key 是否存在，如果不存在直接返回即可，根本无需查缓存和 DB。
BloomFilter 要缓存全量的 key，这就要求全量的 key 数量不大，10亿 条数据以内最佳，因为 10亿 条数据大概要占用 1.2GB 的内存。为了避免记录 key 太多而导致误判率增大，需要定期清零处理。

缓存雪崩:
第一种方案:
对业务 DB 的访问增加读写开关，当发现 DB 请求变慢、阻塞，慢请求超过阀值时，就会关闭读开关，部分或所有读 DB 的请求进行 failfast 立即返回，待 DB 恢复后再打开读开关.
第二种方案:
对缓存增加多个副本，缓存异常或请求 miss 后，再读取其他缓存副本，而且多个缓存副本尽量部署在不同机架，从而确保在任何情况下，缓存系统都会正常对外提供服务。
第三种方案:
对缓存体系进行实时监控，当请求访问的慢速比超过阀值时，及时报警，通过机器替换、服务替换进行及时恢复；也可以通过各种自动故障转移策略，自动关闭异常接口、停止边缘服务、停止部分非核心功能措施，确保在极端场景下，核心功能的正常运行。


## 布隆过滤器
布隆过滤器是一种空间效率很高的概率型数据结构，用于判断一个元素是否在一个集合中。它的核心特点是：
- 高效的空间利用率：相比于传统的哈希表、集合或列表，布隆过滤器使用的空间非常小。例如，存储1亿个元素，只需要约125MB内存。
- 快速的查询性能：判断元素是否存在的时间复杂度为O(k)，其中k是哈希函数的个数，通常是个较小的常数。
- 有一定的误判率：布隆过滤器可能会误判一个不存在的元素为存在（假阳性），但绝不会误判一个存在的元素为不存在（假阴性）。
基本结构是一个位数组，初始所有位都设为0。当向布隆过滤器中添加一个元素时，会使用多个哈希函数计算该元素的哈希值，并将位数组中对应位置设为1。
查询时，如果所有对应位置都为1，则元素可能存在；如果有任一位置为0，则元素一定不存在。

### 工作原理
布隆过滤器的基本结构是一个位数组，初始所有位都设为0。它的工作原理如下
- 添加元素
当向布隆过滤器中添加一个元素时，会使用多个哈希函数计算该元素的哈希值，并将位数组中对应位置设为1。
- 查询元素
查询时，同样使用这些哈希函数计算位置，如果所有对应位置都为1，则元素可能存在；如果有任一位置为0，则元素一定不存在。

这种设计使得布隆过滤器在判断"不存在"时是绝对准确的，而在判断"存在"时可能有误判。

### 关键参数
位数组大小(m)：位数组越大，误判率越低，但内存占用越多
预期元素数量(n)：需要预先估计要存储的元素数量
哈希函数个数(k)：哈希函数数量需要根据预期元素数量和位数组大小来优化

### 局限性
- 不支持删除：标准布隆过滤器不支持删除操作。解决方案是使用计数布隆过滤器或定期重建。
- 误判率增长：随着存储元素数量的增加，误判率会上升。我们通过定期重建和合理设置初始参数来控制误判率。
- 数据量预估：需要预先估计数据量。在实践中，我们通常预留50%的余量，并设置监控阈值，当填充率超过某个阈值时触发重建。


