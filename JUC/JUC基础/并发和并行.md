@[TOC](并发和并行)

## 请解释并发(Concurrency)和并行(Parallelism)的区别
并发(Concurrency)是指多个任务在重叠的时间段内进行处理，但在任一特定时刻，可能只有一个任务在执行。并发是一种逻辑上的同时处理多个任务的能力，即使在单核CPU上也可以实现并发。
并行(Parallelism)是指多个任务在同一时刻同时执行。这需要物理上有多个计算资源（如多核CPU）同时处理不同任务。
关键区别:
并发关注的是任务的结构和管理，强调处理多个任务的能力
并行关注的是任务的执行和性能，强调同时执行的能力
并发可以在单核CPU上实现，而真正的并行需要多核处理器
举例:
并发例子：
一个厨师同时炒三道菜。
厨师不可能真正同时炒三道菜，
而是在三道菜之间来回切换——先炒A菜一会儿，放下去炒B菜,再回来看看A菜是否需要翻炒，然后去炒C菜，如此往复
。这就是并发，一个工作单元（厨师）在多个任务之间切换。
并行例子：
三个厨师分别负责炒三道不同的菜。
每个厨师专注于自己的一道菜，三道菜在同一时间段内被同时处理。
这就是并行，多个工作单元同时处理多个任务。
编程例子:
```java
// Java并发示例
public class ConcurrencyExample {
    public static void main(String[] args) {
        // 创建两个线程
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("线程1: " + i);
                try { Thread.sleep(100); } catch (InterruptedException e) { }
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("线程2: " + i);
                try { Thread.sleep(100); } catch (InterruptedException e) { }
            }
        });
        
        // 启动线程
        thread1.start();
        thread2.start();
    }
}
```
```Java
// Java并行示例
import java.util.Arrays;

public class ParallelismExample {
    public static void main(String[] args) {
        int[] numbers = new int[1000000];
        Arrays.fill(numbers, 1);
        
        // 并行计算数组元素和
        long sum = Arrays.stream(numbers)
                         .parallel()  // 启用并行处理
                         .sum();
        
        System.out.println("Sum: " + sum);
    }
}
```

## 单核CPU能实现并行吗？为什么？
不能。单核CPU在任一时刻只能执行一条指令，因此无法实现真正的并行。
单核CPU只有一个处理单元，在任何时刻只能处理一个任务。
虽然通过操作系统的时间片轮转机制，可以让多个任务看起来是"同时"执行的（这就是并发）.
但从物理层面来说，CPU仍然是在任务间快速切换，而非真正同时执行多个任务。
真正的并行需要多个处理单元（如多核CPU、多CPU系统或分布式系统）同时执行不同的任务。
每个处理单元可以独立执行指令，从而实现物理上的并行处理。

## 请解释多线程和多进程分别是如何实现并发的？它们在并发实现上有什么区别？
### 多线程实现并发
多线程通过在同一进程内创建多个执行流来实现并发。具体机制如下：
共享地址空间：同一进程内的所有线程共享进程的地址空间、代码段、数据段和系统资源
轻量级上下文切换：线程间切换只需要保存和恢复少量寄存器内容，开销较小
线程调度：操作系统的线程调度器负责决定哪个线程获得CPU时间
同步机制：通过锁、信号量、条件变量等机制协调线程间的执行顺序和资源访问
### 多进程实现并发
多进程通过创建多个独立的进程来实现并发。具体机制如下：
独立地址空间：每个进程都有自己独立的地址空间、代码段、数据段和系统资源
重量级上下文切换：进程间切换需要保存和恢复整个进程状态，包括内存映射、文件描述符等，开销较大
进程调度：操作系统的进程调度器负责决定哪个进程获得CPU时间
进程间通信(IPC)：通过管道、消息队列、共享内存、信号等机制实现进程间数据交换和协作

## 阿姆达尔定律(Amdahl's Law)是什么？它对并行计算有什么启示？
阿姆达尔定律是由吉恩·阿姆达尔在1967年提出的，用于计算并行计算中的理论最大加速比。它可以表示为：
S(n) = 1 / [(1-p) + p/n]
其中，S(n)是使用n个处理器的加速比，p是程序中可并行化的比例。
这个定律的核心启示是：程序的加速比受限于其串行部分。无论投入多少计算资源，如果程序有10%无法并行化，那么最大加速比永远不会超过10倍。
对并行计算的主要启示有：
- 串行部分是性能瓶颈，优化串行代码常比增加处理器更有效
- 增加处理器数量会带来收益递减
- 提高程序可并行化比例比增加处理器更能提升性能
- 设计并行系统时应尽量减少全局串行部分
举个例子，如果一个程序有20%的部分无法并行化，那么即使使用无限多的处理器，最大加速比也只有5倍.





