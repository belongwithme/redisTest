# 如何确保消息正确发送到MQ?如何确保消息接收方消费了消息?

- 消息确认机制: 生产者发送消息后,通过消息确认机制(Confirm)确保消息被正确发送到MQ.这个机制分为批量确认和单个确认两种方式,生产者可以选择适合自己业务场景到确认方式.
- 消息持久话: 通过将消息设置为持久化方式,确保消息在发送到MQ后,即使MQ崩溃或者重启,消息仍然可以得到保留.在发送消息时,将消息的delivery mode 设置为2,表示消息需要被持久化.
- 连接超时设置: 发送消息时,设置连接超时时间,当超过指定时间后仍未成功发送消息时,可通过重试等方式确保消息正确发送到MQ.
- 消息序列化和反序列化: 发送和接收消息时,将消息对象序列化为二进制数据,接收方再进行反序列化,确保消息的正确传输.

## 如何避免消息重复投递或重复消息?

- 消息确认机制: 消费者处理消息后,通过发送消息确认(ACK)给MQ,告知消息已被正确处理.如果消费者没有发送确认消息,MQ会讲消息重新投递到队列中,导致重复消息.
- 消息去重机制: 可以实现一个消息去重机制,eg分布式缓存,数据库等存储系统,记录处理过的消息标识,每次处理消息前,先检查该消息是否已经被处理过.
- 消息幂等性处理: 将消费者处理逻辑设置为幂等操作,即重复执行多次仍然具有相同的效果,避免因为消息重复消费导致业务数据错误.
- 设置消息过期时间: 消息发送时设置过期时间,消息过期后不再投递给消费者,避免重复消费.
- 使用消息唯一标识符: 在消息中添加唯一标识符,例如UUID,保证每个消息都有独一无二的标识符,避免重复消费和重复投递.

## 如何保证消息持久化?

- 消息delivery mode 设置为2
- 队列的durable属性设置为 true: 表示队列时持久话的.
- 交换器的durable属性设置为true: 表示交换器时持久话的.
- 使用事物机制: 发送消息时,使用事物机制来确保消息的持久化.

## 消息如何路由?

消息路由过程通过交换器实现,生产者将消息发布到交换器中,然后根据交换器的类型和绑定规则将消息路由到一个或多个队列中.
路由基本流程:
1. 生产者将消息发送到指定的交换器中.
2. 交换器根据[路由键]和[绑定键]将消息发送到一个或多个队列中.路由键和绑定键可以时任意字符串,根据交换器的类型和绑定规则进行匹配.
3. 根据交换机类型,消息可能被路由到一个、多个或零个队列中.
4. 如果没有匹配的队列,消息会被丢弃或返回给生产者,根据生产者的配置.

## 消息确认过程?

消息确认机制是确保消息被正确处理的重要机制,消费者在处理消息后,需要向MQ发送确认消息,告知消息已被正确处理.
作用: 确保MQ消息可以正确将消息从队列中删除,避免重复投递和重复消费.
消息确认过程:
1. 消费者从MQ中获取消息,处理消息.
1. 消费者处理完成后,向MQ发送确认消息(ACK).
2. MQ收到确认消息后,将消息从队列中删除.
3. 如果消费者处理消息失败,可以发送否定确认消息(NACK),告知MQ消息未被正确处理.
4. MQ收到否定确认消息后,会将消息重新投递到队列中,等待下一次消费.

## 消息基于什么传输?

因为TCP连接创建和销毁开销较大,且并发数受系统资源限制,会造成性能瓶颈.
MQ使用信道的方式来传输数据.
信道建立在真实TCP连接内的虚拟连接,每条TCP连接上的信道数量没有限制.


## 为什么不应该对所有的消息都使用持久化机制?

主要是磁盘负担大: 持久化消息需要占用磁盘空间,如果对所有消息都进行持久化,会导致磁盘负担增大,应该根据业务需求和消息重要性,去选择是否使用持久化机制.

如果消息设置了持久化属性,但队列没有设置durable属性,当队列的owner node异常后,且在未重建之前,发送到此队列的消息会丢失.

如果消息和队列都设置了持久话属性,当队列的onwer node异常且无法重启,则该队列无法在其他node上重建,只能等owner node重启后,该队列才可重新恢复使用.

是否要对message持久话,需要综合考虑性能需要,想达到单机10w/秒以上的吞吐量,那么其使用其他的方式去确保消息的可靠传递,要么使用快速的存储系统支持全持久化(SSD).

另外一种处理原则上: 仅对关键消息持久化处理,且保证关键消息的量不会导致性能瓶颈.

## 如何保证高可用的? RabbitMQ的集群?

- 普通集群模式: 多台MQ服务器通过网络连接组成一个集群,共同管理消息队列,并通过节点之间的通信进行消息的传递和路由.
- 镜像集群模式: 每个节点都有多个镜像节点,镜像节点会自动复制主节点的消息队列,并在主节点出现故障的时候接管消息队列的处理.
- Federated集群模式: 将多个MQ集群组成一个逻辑上的整体,并通过Federation插件实现集群之间的消息传递和路由.适用于需要多个数据中心或者地理位置分布的场景,但是会增加网络延迟和复杂度.

## MQ上一个queue中存放的消息是否有数量限制?

- 队列大小限制: 队列大小限制是MQ的一个重要参数,它决定了队列中可以存放的消息数量.如果队列大小超过了限制,新的消息将无法被添加到队列中,导致消息丢失.
- 内存限制: MQ的消息队列上保存在内存中的,当队列消息数量过多时,会占用大量的内存空间.
- 磁盘限制: 磁盘空间也会限制队列中存放消息的数量.

## 单node 系统和多node构成的cluster系统中声明队列,交换机,以及绑定键会有什么不同?

单node: 声明队列时,只需要该node上相关元数据进行变更,就能得到Queue.Declare-ok回应.
cluster:要求cluster上全部node都要进行元数据成功更新才能得到Queue.Declare-ok回应.

若node 类型为 RAM node 则变更的数据仅保存在内存中.
若node 类型为 disk node 则还要变更的保存在磁盘上的数据.

## 客户端连接到duster中的任意node是否都能正常工作?

是的,客户端感觉不到不同.

## 若cluster中拥有某个queue的owner node 失效了,且该queue被声明具有持久化属性,是否能成功从其他node上重新声明该queue?

不能,这种情况下会得到404错误.
只能等quque所属的node恢复后才能使用该queue.
但若该queue本身不具有durable属性,则可在其他node上重新声明.

##  cluster中node的失效对消费者产生什么影响? 若是cluaster创建了mirroredqueue,node失效会对消费者产生什么影响?(疑问?)

- cluster中node的失效: 会在发现TCP连接断开时,按标准行为重连逻辑,根据“Assume Nothing” 原则重建相应对fabric即可.

## 能够在地理上分开不同数据中心使用RabbitMQ cluster吗?

不能.
1. 无法控制创建的queue实际分布在cluster里的哪个node上
2. Erlang的OTP通信框架对延迟的容忍度有限,可能会触发各种超时.
3. 广域网上的连接失效问题会导致经典的“脑裂”问题,RabbitMQ目前无法处理.

## 为什么heavy RPC的使用场景不建议采用disk node?

heavy PRC 指业务逻辑中 高频调用RabbitMQ提供的PRC机制,导致不断创建,销毁reply queue,进而造成disk node的性能问题(会针对元数据不断写盘).
所以使用RPC机制时需要考虑自身的业务场景.

## 向不存在的交换机发publish消息会发生什么? 向不存在的队列执行消费动作会发生什么?

都会收到Channle.Close告知不存在(404).

## 为什么说保证消息被可靠持久化的条件说队列和交换器具有durable属性,同时消息具有持久话属性才行?

### 1. RabbitMQ 的三个层面持久化

要让一条消息真正落盘并在 Broker 重启后依然存在，需要三个条件同时成立：

1. **队列 durable = true**

   * 队列本身必须是持久化队列，否则 Broker 重启后，整个队列都会消失，哪怕消息是持久化的也没地方存。

2. **交换器 durable = true**

   * 消息发布时是先进入交换器，再路由到队列。交换器如果是非持久化的，Broker 重启后它会消失，即使队列还在，消息也可能没法正确路由。

3. **消息 deliveryMode = 2（持久化属性）**

   * 消息默认是瞬时的（非持久化），只有设置为持久化，RabbitMQ 才会把它写入磁盘（具体是写到队列的持久化存储文件中）。

---

### 2. 为什么三个条件缺一不可？

* **只有队列 durable，消息不持久化**：
  队列存在，但消息在内存里，Broker 一挂消息就没了。
* **只有消息持久化，队列不 durable**：
  消息持久化存文件没意义，因为队列没了，RabbitMQ 重启时不会把孤立的消息重新建队列。
* **交换器不 durable**：
  Broker 重启后交换器丢失，即使队列和消息都还在，生产者再发新消息也找不到交换器路由了。

所以，必须 **交换器 durable + 队列 durable + 消息持久化** 才能保证消息在 Broker 崩溃或重启后还能存活。

## Consumer Cancellation Notification 机制用于什么场景?

用于保证当镜像queue中master挂掉时,连接到slave上的消费者可以收到自身消费被取消的通知,进而可以重新执行消费动作从新选出的master上获取消息.

如果不采用,连接到slave上的消费者不会感知master挂掉这个事情,导致后续无法再收到新master广播出来的message.

另外,在镜像queue模式下,存在将message进行requeue的可能,实现consumer逻辑时需要能够正确处理出现重复消息的情况.

## Basic.Reject用法是什么?

可用于消费者对收到的消息进行拒绝.
若此命令设置requeue= true: MQ server收到该拒绝命令后,将该消息重新发送到下一个处于消费状态的消费者.
若此命令设置requeue= false: MQ server收到该拒绝命令后,将该消息丢弃.


## 死信队列和延迟队列的使用?

死信队列: 消息无法被正确处理时,将该消息转发到死信队列中,以便进行进一步的处理.
通过队列,可以将无法处理的消息统一存储和管理,并通过设置合适的TTL和DLX等参数,灵活控制消息的转发和重新处理.

使用死信队列的主要步骤如下:
- 创建一个普通队列和死信交换器.
- 将普通队列绑定到死信交换器,并指定死信队列的路由键.
- 发送消息时,将消息的TTL设置为一个较小的值,当消息未被消费者处理时,该消息会被转发到死信队列中.

延迟队列: 消息在队列中停留一段时间后,再被消费者处理.
通过队列,可以将消息延迟处理,以便在适当的时候再进行处理.
通过设置消息的TTL和DLX等参数,可以将消息转发到一个指定的队列中,以便在一定的时间后再进行处理.

使用延迟队列可以灵活控制消息的发送和处理时间,使用很多场景: 订单超时处理,提醒任务.

使用延迟队列的主要步骤如下:
- 创建一个延迟队列和延迟交换器.
- 将延迟队列绑定到延迟交换器,并指定延迟队列的路由键.
- 发送消息时,将消息的TTL设置为一个较大的值,当消息在队列中停留一段时间后,该消息会被转发到延迟队列中.

## 什么情况下生产者不主动创建queue是安全的?

消息是允许丢失的,实现了针对未处理消息的republish功能.

## 如何保证消息的顺序性?

一个队列只有一个消费者的情况下才能保证顺序,否则只能通过全局ID实现(每个消息都有一个msgId,关联的消息有一个parentMsgId.可以在消费端实现前一条消息未消费,不处理下一条消息,也可以在生产端实现前一条消息未处理完不发下一条消息).

## 无法被路由的消息去了哪里?

- mandatory=true: 消息无法被路由到任何队列时,会返回给生产者.
- mandatory=false: 消息无法被路由到任何队列时,会直接丢弃.

## 消息什么时候变成死信?

1. 消息拒绝并且没有设置重新入队: 消费者使用basic.reject或者basic.nack拒绝消息,并且requeue参数设置未false时.
2. 消息过期: 如果消息在队列中的存活时间超过了设置的TTL(Time to Live)时间.
3. 消息堆积,并且队列达到最大长度: 先入队的消息会变成DL.

## Rabbitmq事务机制?

RabbitMQ支持事物机制,用于在发送消息时保证事务的原子性.

事务机制允许在多个RabbitMQ操作中声明事务,并在最终确认消息被完全处理之前,将多个操作打包为一个原子操作.

在RabbitMQ中,事务机制的使用流程如下:
- 开启事务: 再发送消息之前,使用txSelect方法开启事务;
- 发送消息: 使用basicPublish方法发送消息;
- 提交事务: 使用txCommit方法提交事务,如果提交成功,则消息会被RabbitMQ确认,否则消息会被回滚;
- 回滚事务: 使用txRollback方法回滚事务,如果回滚成功,则之前发送的消息会被撤销,否则消息会被继续处理.

使用事务机制会对MQ的性能产生影响,一般在消息可靠性要求非常高的场景下才会用.
消息量大的场景下,可以使用替代方案,eg: 消息确认机制(ACK机制)保证系统的高性能和可靠性.
