@[TOC](CMS垃圾收集器)

## 请详细描述CMS垃圾收集器的工作原理及各个阶段
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的老年代收集器，基于标记-清除算法实现。CMS收集过程分为四个主要阶段：
1. 初始标记（Initial Mark）：标记GC Roots直接关联的对象。这个阶段需要"Stop The World"，但时间很短。
2. 并发标记（Concurrent Mark）：从GC Roots开始对堆中对象进行可达性分析，标记活着的对象。这个阶段与用户线程并发执行。
3. 重新标记（Remark）：修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。这个阶段需要"Stop The World"，但比初始标记时间长，比并发标记时间短。
4. 并发清除（Concurrent Sweep）：清除标记阶段判断的已死亡对象，释放内存空间。这个阶段与用户线程并发执行。

个人理解版本:
CMS收集器的本质是一种低延迟的老年代回收方案，它通过"边运行边清理"的方式降低停顿时间。
CMS的工作原理围绕一个核心目标：在应用运行的同时完成大部分垃圾回收工作。它像一个"后勤人员"，尽可能不打扰正在工作的"前线士兵"（应用线程）。回收过程分为四个阶段：
1. 初始标记：这是一个短暂的"暂停"阶段，就像在繁忙的公路上短暂设置检查点，只标记与GC Roots直接相连的对象。虽然需要停顿，但时间非常短暂，通常只有几十毫秒。
2. 并发标记：这是CMS的核心阶段，垃圾收集器在后台默默工作，沿着对象引用链条进行标记，同时允许应用程序继续运行。这就像是在高速公路上行驶的汽车旁边，有工人在不影响交通的情况下进行道路检查。
3. 重新标记：由于并发标记期间应用仍在运行，对象引用可能发生变化，需要再次短暂停顿，修正这些变动。这相当于在完成大部分检查后，再次短暂设卡确认最新情况。
4. 并发清除：垃圾收集器再次与应用并发执行，清除已经标记为垃圾的对象，释放内存空间。这时，应用程序已经可以使用刚才识别的所有存活对象，同时垃圾收集器在后台默默清理无用对象。

整个过程中，只有初始标记和重新标记需要短暂停顿，其余阶段均与应用并发执行，这使得CMS成为当时最具低延迟特性的垃圾收集器。
## 与其他垃圾收集器相比，CMS有哪些独特优势和明显缺点？
优势：
- 并发收集：大部分工作与用户线程并发执行，大幅减少停顿时间
- 低延迟：适合对响应时间要求高的应用，如Web服务器
- 分代收集：与年轻代收集器配合使用，有效处理不同生命周期的对象
缺点：
- CPU资源敏感：并发阶段会占用一部分CPU资源，总吞吐量降低
- 无法处理浮动垃圾：并发标记和并发清除阶段用户线程还在运行，会产生新的垃圾，只能等下次GC才能清除
- 产生内存碎片：基于标记-清除算法，会产生大量内存碎片，可能导致大对象分配失败触发Full GC
- 并发失败风险：如果老年代内存增长过快，来不及完成清理就会触发"Concurrent Mode Failure"，导致启用Serial Old收集器进行Full GC

个人理解版本:
CMS的核心优势在于它的"并发"特性，它重新定义了垃圾收集器的设计思路。
优势角度：
1. 低延迟体验：CMS将停顿时间分散成更小的片段，大部分工作与应用并发执行，这对响应敏感型应用（如交互式网站、金融交易系统）至关重要。我曾在一个在线交易平台中引入CMS，将平均响应时间降低了30%，大幅提升了用户体验。
2. 资源利用灵活性：CMS允许在多核环境下更灵活地分配CPU资源，可以通过参数控制垃圾收集线程数量，平衡GC速度和应用性能。
3. 增量收集能力：通过-XX:+CMSIncrementalMode参数，CMS甚至可以在单CPU环境下进行增量回收，进一步减少对应用的影响。
缺点角度：
1. "并发"的代价：CMS的并发特性是以牺牲吞吐量和空间效率为代价的。垃圾收集线程与应用线程争抢CPU资源，在CPU密集型应用中可能导致整体性能下降20%-30%。
2. 内存碎片问题：基于标记-清除算法，CMS不会重排内存，长期运行后会产生大量不连续内存空间。在我经历的一个长时间运行的系统中，3天后因碎片问题不得不触发了Full GC。
3. 浮动垃圾与预留空间：CMS无法处理并发清理阶段产生的新垃圾，且需要预留部分内存防止并发失败。这意味着CMS在默认设置下会在老年代使用68%时就开始回收，实际可用内存比其他收集器少。
4. 并发失败风险：如果老年代填满速度过快，CMS来不及回收，就会触发"Concurrent Mode Failure"，导致启用Serial Old收集器作为后备方案，这反而会造成更长的停顿时间。
## CMS为什么被称为"并发"收集器？这与"并行"收集器有何区别？
CMS被称为"并发"收集器是因为它的大部分工作（并发标记、并发清除阶段）是与用户线程一起并发执行的，不需要暂停用户线程。
并发与并行的区别：
- 并发（Concurrent）：指垃圾收集器线程与用户线程同时执行，但不一定是同一时刻，是指多个任务在同一时间段内交替执行。CMS就是典型的并发收集器。
- 并行（Parallel）：指垃圾收集器线程之间的关系，指多条垃圾收集线程同时工作，用户线程仍然处于等待状态。如Parallel Scavenge、Parallel Old收集器。

"并发"关注的是用户体验（减少停顿），"并行"关注的是吞吐量（利用多核心缩短垃圾收集时间）。CMS使用并发的方式减少停顿时间，牺牲了部分吞吐量，而并行收集器则相反。

个人理解版本:
CMS被称为"并发"收集器，体现了它的核心设计哲学——垃圾收集应尽量不妨碍应用程序的正常运行。
这里的关键在于理解"并发"与"并行"这两个看似相似但实际有本质区别的概念：
"并发"(Concurrent)是指垃圾收集器与应用程序线程同时工作的能力。想象一下高速公路上同时有普通车辆（应用线程）和清扫车（GC线程）行驶，它们互不干扰地共享道路资源。CMS大部分工作是与应用线程一起执行的，这极大降低了应用的停顿时间。
"并行"(Parallel)则指的是垃圾收集器自身使用多线程并行工作的能力。这相当于在清理高速公路时，短暂关闭道路，但派出多辆清扫车同时作业，以缩短关闭时间。Parallel Scavenge、Parallel Old这类收集器就是并行工作的典型代表，它们在GC时会停止所有应用线程，但会使用多线程加速垃圾收集过程。
从实际应用价值看，"并发"收集器适合对响应时间敏感的交互式应用，如网站前端、交易系统、游戏服务器等；而"并行"收集器则适合对吞吐量要求高的后台计算型应用，如数据分析、批处理作业等。
值得注意的是，现代收集器如G1、ZGC兼具了并发和并行特性，它们不仅与应用并发执行，自身也采用了并行设计，进一步提升了垃圾收集效率
## 什么情况下会发生CMS的并发失败（Concurrent Mode Failure）？如何调优避免？
并发失败（Concurrent Mode Failure）主要发生在以下情况：
1. 老年代内存增长过快，CMS回收速度跟不上内存分配速度
2. 老年代空间不足以容纳晋升的对象
3. 内存碎片导致大对象无法分配
避免并发失败的调优方法：
1. 增大老年代空间（-XX:CMSInitiatingOccupancyFraction）
2. 提前触发CMS收集（降低CMSInitiatingOccupancyFraction参数值）
3. 增加并发收集线程数（-XX:ConcGCThreads）
4. 开启内存碎片整理（-XX:+UseCMSCompactAtFullCollection）
5. 控制碎片整理频率（-XX:CMSFullGCsBeforeCompaction）
个人理解版本
CMS并发失败，本质上是一场"内存分配"与"垃圾回收"之间的赛跑失败。
想象一下，CMS像是一位后台清洁工，在商场开放的同时进行清扫。但如果突然涌入大量顾客（大量对象创建）或者商品摆放过于混乱（内存碎片），清洁工就跟不上节奏了。这时，商场不得不临时关闭（触发Full GC），进行彻底清理。
我在一个交易系统中遇到过这个问题。系统每天下午交易高峰期会突然创建大量对象，导致老年代快速填充，CMS来不及回收就触发并发失败。分析GC日志后发现，问题出在两方面：
1. 对象产生速率过快：高峰期每秒新增对象占用空间约50MB
2. CMS启动阈值设置过高：默认92%时才开始回收
解决方案：
1. 将-XX:CMSInitiatingOccupancyFraction从默认值调至60%，给CMS预留更多工作时间
2. 增加-XX:ConcGCThreads参数，提升并发回收线程数
3. 引入-XX:+CMSScavengeBeforeRemark参数，在重新标记前进行一次Young GC，减少需处理对象
## 在实际项目中，你如何判断CMS是否适合你的应用场景？
判断CMS是否适合应用场景，需要从以下几个方面考量：
1. 应用对延迟的敏感度：CMS适合对响应时间要求高的应用，如Web服务、交互式系统
2. 服务器资源情况：CMS会占用一部分CPU资源进行并发回收，服务器需有足够的计算资源
3. 内存使用模式：CMS不适合内存分配速率过快的场景，可能导致并发失败
4. 内存碎片敏感度：CMS会产生内存碎片，长期运行的系统需考虑碎片整理开销
5. JDK版本：JDK9已废弃CMS，JDK14后不可用，需考虑使用G1代替
## CMS收集器中的"三色标记"算法是如何工作的？
CMS收集器采用的三色标记算法是一种追踪式垃圾回收算法，通过三种颜色标记对象的不同状态：
1. 白色：未被标记的对象，垃圾回收开始时所有对象都是白色，最终仍为白色的对象会被回收
2. 灰色：已被标记但其引用对象尚未完全标记的对象，表示对象正在被处理
3. 黑色：已被标记且其所有引用对象都已标记的对象，表示对象及其引用对象都已安全
三色标记的工作流程：
1. 初始时所有对象都是白色
2. 将GC Roots直接引用的对象标记为灰色
3. 从灰色集合中取出一个对象，将其引用的所有白色对象标记为灰色，然后将自身标记为黑色
4. 重复第3步，直到灰色集合为空
5. 此时所有可达对象都是黑色，白色对象即为垃圾

在并发标记过程中，由于用户线程与垃圾收集线程并发执行，可能出现对象引用关系变化，导致标记结果不准确。
这种情况下可能出现两个典型问题：
1. 浮动垃圾：并发标记过程中，一个黑色对象可能将引用指向一个新的白色对象，但由于黑色对象已经处理完毕，不会再被扫描，导致这个新的白色对象无法被标记为灰色，最终被错误回收
2. 对象丢失：一个黑色对象的引用可能被修改，不再指向某个白色对象，而这个白色对象也不被其他对象引用，导致这个本应存活的对象被错误回收

为解决这个问题，CMS采用增量更新（Incremental Update）机制，通过写屏障技术记录并发阶段引用关系的变化，在重新标记阶段再次处理这些变化。
简单来说，就像是你在整理房间时，有一个助手记录下所有发生变化的物品，然后在最后一轮检查（重新标记阶段）时，专门处理这些变化过的物品。
## CMS被JDK9标记为废弃，被JDK14移除的原因是什么？G1相比CMS有哪些改进？
八股文版本
1. CMS被废弃和移除的原因:
- 复杂的实现和维护成本高
- 内存碎片问题严重，长期运行需要定期整理
- 并发失败问题难以彻底解决
- 对处理超大堆性能表现不佳
- G1收集器提供了更好的替代方案
2. G1相比CMS的改进:
- 采用区域化分代的设计，避免了整堆扫描
- 可预测的停顿时间模型，通过-XX:MaxGCPauseMillis指定期望停顿时间
- 内存整理与回收同步进行，降低内存碎片产生
- 更高效的回收算法，优先回收垃圾最多的区域（Garbage First）
- 支持并行与并发，兼顾了吞吐量和响应时间
- 分阶段的标记复制算法，平衡了低延迟和高吞吐量

## CMS的卡表（Card Table）和增量更新（Incremental Update）机制如何解决并发标记的问题？
CMS并发标记阶段面临的核心问题是：当垃圾收集线程在标记对象时，应用线程可能正在修改对象引用关系，导致标记结果不准确。为解决这一问题，CMS采用了卡表和增量更新两种关键机制：
1. 卡表（Card Table）：
- 将整个堆内存划分为固定大小的卡页（Card）
- 每个卡页对应卡表中的一个标记位
- 当应用线程修改引用关系时，通过写屏障技术将对应卡页标记为"脏"（Dirty）
- 垃圾收集器在重新标记阶段只需重新扫描脏卡页，避免重新扫描整个堆
2. 增量更新（Incremental Update）：
- 专门解决并发标记中的对象漏标记问题
- 当黑色对象新增对白色对象的引用时，通过写屏障将黑色对象重新标记为灰色或记录引用变化
- 在重新标记阶段，再次扫描这些引用变化，确保不会漏标记对象
- 主要解决"对象丢失"问题，保证可达对象不会被错误回收
这两种机制相互配合，确保了CMS并发标记的正确性，同时将停顿时间控制在可接受范围内。
## 你能否解释CMS中的浮动垃圾（Floating Garbage）概念及其产生原因？
浮动垃圾（Floating Garbage）是指CMS并发收集过程中新产生的垃圾，这些垃圾在当前收集周期无法被清除，只能留待下一次GC时才能回收。
产生原因：
1. CMS的并发标记阶段与用户线程并发执行
2. 在标记完成后，对象引用关系可能发生变化
3. 一个对象在标记阶段被标记为存活，但在并发清除阶段变成了垃圾
4. 由于这个对象已经被标记为存活，本次GC不会回收它
浮动垃圾的影响：
1. 降低了内存利用率，部分垃圾对象会继续占用堆空间
2. 导致CMS需要预留部分内存空间，默认会在老年代使用68%时就触发垃圾收集
3. 增加了垃圾收集的频率
CMS通过合理设置触发阈值（CMSInitiatingOccupancyFraction参数）来预留足够空间应对浮动垃圾，避免出现并发收集失败。


## 老年代有哪些垃圾回收器
Java虚拟机中针对老年代的垃圾收集器主要有：
1. Serial Old收集器：单线程收集器，使用标记-整理算法，是JDK1.5之前Client模式下默认的老年代收集器
2. Parallel Old收集器：多线程并行收集器，使用标记-整理算法，是Parallel Scavenge的老年代版本
3. CMS（Concurrent Mark Sweep）收集器：低延迟收集器，使用标记-清除算法，以获取最短回收停顿时间为目标
4. G1收集器：全堆收集器，虽然可以回收整个堆，但也分代管理，JDK9后成为默认收集器
5. ZGC收集器：可扩展的低延迟收集器，在JDK11中引入，目标是10ms以内的停顿时间
6. Shenandoah收集器：与ZGC类似的低延迟收集器，由Red Hat开发
每种收集器有不同的适用场景和性能特点，需要根据应用需求选择合适的收集器。

## CMS的特性

CMS（Concurrent Mark Sweep）收集器的主要特性包括：
1. 以获取最短回收停顿时间为目标，适合对响应时间要求高的应用
2. 基于标记-清除算法实现，不进行内存压缩
3. 分为四个主要阶段：初始标记、并发标记、重新标记和并发清除
4. 只有初始标记和重新标记阶段需要"Stop The World"，其余阶段与用户线程并发执行
5. 并发执行特性使其占用部分CPU资源，可能影响吞吐量
6. 无法处理浮动垃圾（Floating Garbage），需要预留部分内存空间
7. 会产生内存碎片，可能导致长期运行后的分配问题
8. 当内存回收速度跟不上分配速度时，会触发并发失败（Concurrent Mode Failure）
CMS主要适用于互联网站或B/S系统的服务端应用，这类应用通常对响应速度要求较高。
## CMS如何保证用户线程不影响标记结果
CMS保证用户线程不影响标记结果的关键机制包括：
1. 三色标记法：将对象分为白色（未访问）、灰色（已访问但引用未遍历完）和黑色（已访问且引用已遍历完）
2. 写屏障（Write Barrier）技术：在用户修改引用关系时，JVM会插入额外代码记录引用变化
3. 增量更新（Incremental Update）：当黑色对象新增对白色对象的引用时，记录下引用变化或将黑色对象重新标记为灰色
4. 卡表（Card Table）：将内存划分为固定大小的卡页，引用变化时标记对应卡页为"脏"
5. 重新标记（Remark）阶段：专门用来修正并发标记期间引用变化导致的标记错误
6. 安全点（Safepoint）：在重新标记阶段，确保所有线程都停在安全点上，防止引用继续变化
7. SATB（Snapshot At The Beginning）：保留开始标记时的对象图快照，确保一致性
通过这些机制的协同工作，CMS确保了即使在用户线程并发修改引用的情况下，垃圾收集的正确性也不会受到影响。

## 怎么解决二阶段（并发标记）时用户线程对引用的修改产生的变动  
CMS在并发标记阶段面临的核心挑战是"读-写竞争"问题。想象一下，当垃圾收集器正在打扫房间（标记对象）时，房间主人（用户线程）仍在不停地移动物品（修改引用关系）。这种情况下可能发生两种典型问题：
1. 对象丢失问题：黑色对象指向白色对象的引用被删除，同时白色对象被其他灰色对象引用，但这个灰色对象尚未被扫描到，导致白色对象被错误回收。
2. 浮动垃圾问题：对象在标记为存活后又变成了垃圾，但当前回收周期无法处理它。
为解决这些问题，CMS采用了以下关键机制：
1. 写屏障技术：在JVM层面，当用户线程修改引用关系时，会触发特殊的代码片段（写屏障）。这就像在每个门上安装了监控器，任何人进出都会被记录下来。
2. 增量更新（Incremental Update）：当黑色对象新增对白色对象的引用时，写屏障会将这个黑色对象重新标记为灰色或记录下这个新增引用。这确保了新引用的白色对象不会被错过。
3. 卡表（Card Table）：将内存空间划分为固定大小的卡页，每当一个卡页内的对象引用发生变化，就将对应卡表中的标记位置为"脏"。这样在重新标记阶段只需扫描脏卡页，而不是整个堆。
4. 重新标记阶段：在并发标记结束后，专门设计了这个短暂的"Stop The World"阶段，用于处理并发标记期间的引用变化。这相当于最后一次全面检查，确保不遗漏任何活跃对象。

## 被用户修改的引用，你觉得记在哪里比较合适，或者如何设计记录这种被用户修改的引用
对于被用户修改的引用，我认为设计一个高效的记录方式应包含以下几个关键点：
1. 分层卡表结构：
最合适的记录方式是采用分层的卡表结构。
基础层使用细粒度的卡表（如每512字节一个卡页）.
上层使用粗粒度的摘要表（如每个摘要表项对应64个卡表项）。
这种层次结构能在快速定位脏区域和减少内存占用间取得平衡。
2. 写前屏障与写后屏障结合：
- 写后屏障（Post-Write Barrier）负责记录新增的引用关系
- 写前屏障（Pre-Write Barrier）负责记录即将被删除的引用关系

增量缓冲区（Remembered Set）：除了卡表外，还可设计一个增量缓冲区专门记录黑色对象新增的白色对象引用。这种方式在引用变化频繁的场景下比重新将对象标记为灰色更高效。

## 假设你设计一个cms，还原垃圾回收的流程，你会怎么操作 
首先，初始标记阶段需要短暂暂停所有用户线程，只标记与GC Roots直接关联的对象。这个阶段我会使用多线程并行处理，控制停顿时间在10毫秒以内。
接下来是并发标记阶段，恢复用户线程运行，垃圾收集线程同时工作。这里我会实现三色标记法追踪对象引用，同时通过写屏障机制和分层卡表结构记录用户线程对引用的修改。并发标记是CMS的核心，我会关注引用变化的高效记录和处理。
第三阶段是重新标记，再次短暂暂停用户线程，处理并发标记期间记录的所有引用变化。这里我会扫描脏卡页区域，确保不遗漏任何存活对象。为提高效率，会使用多线程并行处理，并考虑在此之前触发一次Young GC减少标记工作量。
最后是并发清除阶段，恢复用户线程运行，同时并发回收已标识的垃圾对象。我会使用多线程并发清理，优先回收大块连续空间，并实时更新空闲列表。
除了基本流程，我还会关注几个关键优化点：一是动态调整触发阈值，根据历史填充速率预测最佳回收时机；二是设计合理的碎片处理策略，在必要时进行内存整理；三是实现并发失败的快速恢复机制，确保系统稳定性。

## 刚才说记录用户修改的引用，那用户线程不会主动去记录，如何感知用户对引用的修改 
JVM通过写屏障（Write Barrier）技术来感知用户线程对引用的修改。写屏障本质上是JVM自动插入的一段代码，它会在引用类型的赋值操作前后执行。
当编译Java代码时，JVM会在所有引用赋值操作（比如对象引用的赋值语句）处插入额外的指令。
写屏障的实现通常是将修改发生的内存区域（卡页）标记为'脏'，而不是记录具体的对象引用，这种粗粒度的标记方式可以大幅降低性能开销。
这种机制确保了垃圾收集器能够准确追踪所有引用变化，同时对应用程序的性能影响降到最低，应用开发者无需关注这些底层细节，也不需要编写额外代码来支持垃圾收集。"