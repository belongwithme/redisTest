# Java垃圾回收详解

## 一、垃圾回收基础概念

### 1. 什么是垃圾回收

垃圾回收（Garbage Collection，简称GC）是Java虚拟机（JVM）的一种自动内存管理机制，用于识别和清除不再使用的对象，释放和重用内存。它使得开发人员不需要像C/C++那样手动管理内存，避免了内存泄漏和内存碎片等问题。

### 2. 垃圾回收的意义

1. **自动内存管理**：解放开发者，不需要手动释放内存
2. **提高内存使用效率**：及时回收不再使用的对象所占用的内存空间
3. **防止内存泄漏**：自动识别和清除不再使用的对象
4. **提高程序稳定性**：避免因内存问题导致的程序崩溃

### 3. GC中的基本术语

- **存活对象**：仍然被引用的对象
- **垃圾对象**：不再被引用的对象
- **垃圾回收器**：负责回收垃圾对象的组件
- **Stop-the-World**：垃圾回收过程中，Java应用的所有线程都必须暂停的状态
- **Minor GC**：只回收新生代的垃圾
- **Major GC**：只回收老年代的垃圾
- **Full GC**：回收整个堆包括新生代、老年代和元空间（JDK 8之前是永久代）的垃圾

## 二、垃圾标识算法

在JVM中，垃圾回收首先需要确定哪些对象是"垃圾"（即不再使用的对象）。主要有以下几种算法：

### 1. 引用计数法（Reference Counting）

每个对象都有一个引用计数器，当有一个地方引用它时计数器加1，引用失效时减1。当计数器为0时，表示对象不再被使用，可被回收。

**优点**：
- 简单直观
- 回收及时

**缺点**：
- 无法解决循环引用问题
- 计数器本身消耗资源
- 每次引用变化都需要更新计数器，带来额外开销

**注意**：Java的JVM垃圾回收并不使用引用计数法作为主要算法，因为它无法解决循环引用问题。

### 2. 可达性分析算法（Reachability Analysis）

从GC Roots（根对象）出发，通过引用链找到所有可达对象，这些对象被标记为活动对象。不可达的对象被视为垃圾，可以回收。

**GC Roots包括**：
- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（Native方法）引用的对象
- 活跃线程对象

**优点**：
- 能解决循环引用问题
- 标记效率较高

**缺点**：
- 需要暂停应用线程（Stop-the-World），对实时性要求高的应用有影响

### 3. 分代垃圾回收

基于对象生命周期的不同，JVM将堆内存分为年轻代和老年代，分别采用不同的回收策略。这是大多数现代JVM使用的主要方法。

## 三、垃圾回收算法

确定了哪些对象需要回收后，接下来就是如何回收这些对象，释放内存空间。

### 1. 标记-清除算法（Mark-Sweep）

分为两个阶段：
- **标记阶段**：标记所有需要回收的对象
- **清除阶段**：清除被标记的对象，释放内存

**优点**：
- 实现简单

**缺点**：
- 效率不高，标记和清除两个过程都比较耗时
- 会产生大量内存碎片，导致无法分配大对象

### 2. 复制算法（Copying）

将内存分为两个相等的区域，每次只使用其中一个区域。当这个区域内存不足时，就将存活对象复制到另一个区域，然后清空当前区域。

**优点**：
- 高效，不会产生内存碎片
- 适合存活对象较少的场景（如新生代）

**缺点**：
- 浪费50%的内存空间
- 如果存活对象较多，复制成本高

### 3. 标记-整理算法（Mark-Compact）

分为三个阶段：
- **标记阶段**：与标记-清除算法一样，标记所有需要回收的对象
- **整理阶段**：将所有存活对象移动到内存的一端
- **清除阶段**：清除边界以外的所有对象

**优点**：
- 不会产生内存碎片
- 适合存活对象较多的场景（如老年代）

**缺点**：
- 需要移动对象，成本较高

### 4. 分代收集算法（Generational Collection）

根据对象的生命周期不同，将堆内存划分为年轻代和老年代，分别采用不同的回收算法：
- **年轻代**：使用复制算法，因为年轻代对象生命周期短，存活率低
- **老年代**：使用标记-整理或标记-清除算法，因为老年代对象生命周期长，存活率高

**优点**：
- 结合各种算法的优点
- 针对不同年龄对象特点，采用最合适的算法

**缺点**：
- 算法实现复杂
- 需要维护多个内存区域

## 四、Java中的分代垃圾回收

### 1. 堆内存分区

在大多数JVM实现中，堆内存被分为以下几个部分：

- **年轻代（Young Generation）**
  - **Eden区**：大多数新创建的对象首先被分配在Eden区
  - **Survivor区**：分为S0和S1（或From和To），用于存放经过垃圾回收后依然存活的对象
- **老年代（Old/Tenured Generation）**：存放长时间存活的对象
- **元空间/永久代**：JDK 8之前称为永久代（Permanent Generation），JDK 8及以后称为元空间（Metaspace），用于存储类的元数据

### 2. 分代垃圾回收过程

#### 年轻代（Minor GC）

1. **对象优先在Eden区分配**
2. **当Eden区满时，触发Minor GC**
3. **清理Eden区和From Survivor区，将存活对象复制到To Survivor区**
4. **交换From和To Survivor的角色**
5. **如果对象在Survivor区中存活了足够多次GC（默认为15次，通过`-XX:MaxTenuringThreshold`设置），则晋升到老年代**

#### 老年代（Major GC / Full GC）

1. **老年代的GC一般伴随着年轻代的GC一起发生（即Full GC）**
2. **使用标记-整理算法**
3. **触发条件**：
   - 老年代空间不足
   - 方法区空间不足
   - 显式调用System.gc()（不建议使用）
   - 年轻代晋升到老年代的对象大小超过老年代剩余空间
   - CMS GC出现Concurrent Mode Failure

## 五、常见的垃圾回收器

### 1. Serial收集器

串行收集器，单线程执行，会导致Stop-the-World。适用于单CPU环境。

- **特点**：简单高效，没有线程切换开销
- **适用场景**：客户端应用，内存小的场景

### 2. ParNew收集器

Serial收集器的多线程版本，除了使用多条线程进行垃圾回收外，其余行为与Serial收集器一样。

- **特点**：多线程并行收集，适合多CPU环境
- **适用场景**：与CMS配合使用的年轻代收集器

### 3. Parallel Scavenge收集器

关注吞吐量的多线程收集器，可以通过参数控制吞吐量和GC停顿时间。

- **特点**：高吞吐量，适合后台运算任务
- **适用场景**：注重吞吐量而不是响应时间的场景

### 4. Parallel Old收集器

Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。

- **特点**：与Parallel Scavenge配合，构成全并行的垃圾回收器组合
- **适用场景**：注重吞吐量的服务器环境

### 5. CMS（Concurrent Mark Sweep）收集器

以获取最短回收停顿时间为目标的收集器，采用标记-清除算法。

- **特点**：低延迟，大部分工作与用户线程并发执行
- **工作流程**：
  1. 初始标记（CMS initial mark）：标记GC Roots直接关联的对象，会导致短暂停顿
  2. 并发标记（CMS concurrent mark）：进行GC Roots Tracing，与用户线程并发
  3. 重新标记（CMS remark）：修正并发标记期间用户线程导致的标记变动，会导致短暂停顿
  4. 并发清除（CMS concurrent sweep）：清除不再使用的对象，与用户线程并发
- **缺点**：
  - 对CPU资源敏感
  - 无法处理浮动垃圾（Floating Garbage）
  - 会产生内存碎片

### 6. G1（Garbage-First）收集器

面向服务端应用的收集器，目标是替代CMS。G1将堆分为大小相等的区域（Region），不再有固定的年轻代和老年代的区分。

- **特点**：
  - 并行与并发
  - 分代收集
  - 空间整合
  - 可预测的停顿
- **工作流程**：
  1. 初始标记（Initial Marking）：标记GC Roots直接关联对象，会导致短暂停顿
  2. 并发标记（Concurrent Marking）：与用户线程并发执行
  3. 最终标记（Final Marking）：处理并发标记阶段遗留下来的少量SATB记录，会导致短暂停顿
  4. 筛选回收（Live Data Counting and Evacuation）：对各个Region的回收价值和成本进行排序，根据用户期望的停顿时间来制定回收计划

### 7. ZGC（Z Garbage Collector）

JDK 11引入的低延迟垃圾收集器，目标是在任何堆大小下都能将停顿时间控制在10ms以内。

- **特点**：
  - 并发
  - 基于区域
  - 标记-整理
  - 使用读屏障
  - NUMA感知
- **优点**：
  - 停顿时间极短
  - 扩展性好，可处理TB级别的堆
  - 对大堆和大型对象有优势

### 8. Shenandoah收集器

OpenJDK开发的与ZGC类似的低延迟垃圾收集器，目标也是将GC停顿时间控制在10ms以内。

- **特点**：
  - 并发
  - 疏散（evacuation）阶段也是并发的
  - 使用读屏障和写屏障
- **优点**：
  - 停顿时间短
  - 支持任意大小的堆

## 六、垃圾回收器的选择

选择合适的垃圾回收器应考虑以下因素：

### 1. 应用程序的特点

- **响应时间要求**：对于交互式应用，应选择停顿时间短的收集器（如CMS、G1、ZGC）
- **吞吐量要求**：对于批处理任务，应选择吞吐量高的收集器（如Parallel Scavenge、Parallel Old）
- **堆内存大小**：对于大内存应用，应选择可扩展性好的收集器（如G1、ZGC）

### 2. 系统资源

- **CPU资源**：多线程收集器需要更多CPU资源
- **内存资源**：不同收集器对内存的利用率不同

### 3. JDK版本

- JDK 8及以前：Serial、ParNew、Parallel Scavenge、CMS、G1
- JDK 11及以后：增加ZGC
- OpenJDK：增加Shenandoah

### 4. 常见收集器组合

- **Serial + Serial Old**：客户端应用，内存小
- **ParNew + CMS**：注重响应时间的服务端应用
- **Parallel Scavenge + Parallel Old**：注重吞吐量的服务端应用
- **G1**：大内存、需要低延迟的服务端应用
- **ZGC/Shenandoah**：超大内存、极低延迟要求的服务端应用

## 七、垃圾回收调优

### 1. 垃圾回收调优的目标

- **减少Full GC的频率**
- **减少GC的停顿时间**
- **提高吞吐量**

### 2. 常用调优参数

#### 堆内存大小

- `-Xms`：初始堆大小
- `-Xmx`：最大堆大小
- `-Xmn`：新生代大小
- `-XX:SurvivorRatio`：Eden区与Survivor区比例
- `-XX:NewRatio`：新生代与老年代比例

#### 垃圾回收器选择

- `-XX:+UseSerialGC`：使用Serial + Serial Old收集器
- `-XX:+UseParNewGC`：使用ParNew + Serial Old收集器
- `-XX:+UseParallelGC`：使用Parallel Scavenge + Parallel Old收集器
- `-XX:+UseConcMarkSweepGC`：使用ParNew + CMS + Serial Old收集器
- `-XX:+UseG1GC`：使用G1收集器
- `-XX:+UseZGC`：使用ZGC收集器
- `-XX:+UseShenandoahGC`：使用Shenandoah收集器

#### CMS收集器参数

- `-XX:CMSInitiatingOccupancyFraction`：老年代使用多少比例时开始CMS收集
- `-XX:+UseCMSCompactAtFullCollection`：Full GC后进行内存整理
- `-XX:CMSFullGCsBeforeCompaction`：多少次Full GC后进行一次内存整理

#### G1收集器参数

- `-XX:MaxGCPauseMillis`：期望的最大GC停顿时间
- `-XX:G1HeapRegionSize`：G1 Region大小
- `-XX:InitiatingHeapOccupancyPercent`：触发并发GC周期的Java堆占用率

### 3. 垃圾回收日志分析

开启GC日志：
- `-XX:+PrintGCDetails`：打印GC详细信息
- `-XX:+PrintGCDateStamps`：打印GC时间戳
- `-Xloggc:filename`：将GC日志输出到文件

通过分析GC日志，可以：
- 了解GC发生的频率和原因
- 识别GC过程中的问题
- 调整GC参数

### 4. 调优策略

- **根据应用特点选择合适的收集器**
- **避免显式调用System.gc()**
- **合理设置堆内存大小**
- **优化对象分配和生命周期**
- **考虑使用软引用和弱引用**
- **减少大对象的分配**
- **避免内存泄漏**

## 八、Java中的引用类型与垃圾回收

Java提供了四种引用类型，它们在垃圾回收时有不同的处理方式：

### 1. 强引用（Strong Reference）

最常见的引用类型，如`Object obj = new Object()`。只要强引用存在，垃圾回收器永远不会回收被引用的对象。

### 2. 软引用（Soft Reference）

用于描述一些有用但非必需的对象。在系统将要发生内存溢出之前，会回收这些对象。通过`SoftReference`类实现。

```java
SoftReference<Object> softRef = new SoftReference<>(new Object());
```

### 3. 弱引用（Weak Reference）

描述非必需对象。当垃圾回收器扫描到只被弱引用关联的对象时，无论内存是否充足，都会回收这些对象。通过`WeakReference`类实现。

```java
WeakReference<Object> weakRef = new WeakReference<>(new Object());
```

### 4. 虚引用（Phantom Reference）

最弱的引用类型，几乎不会对对象的生命周期产生影响。主要用于跟踪对象被垃圾回收的状态。通过`PhantomReference`类实现。

```java
PhantomReference<Object> phantomRef = new PhantomReference<>(new Object(), new ReferenceQueue<>());
```

## 九、内存泄漏与垃圾回收

即使有垃圾回收机制，Java程序仍然可能出现内存泄漏问题。

### 1. 常见的内存泄漏场景

- **静态集合类**：静态集合类引用的对象不会被回收
- **单例模式**：单例对象持有外部对象的引用
- **未关闭的资源**：如文件、数据库连接、网络连接等
- **内部类和匿名内部类**：持有外部类的引用
- **ThreadLocal使用不当**：线程池中的ThreadLocal变量未及时清理
- **监听器和回调**：注册监听器但未反注册

### 2. 内存泄漏检测工具

- **JVM自带工具**：jmap、jstat、jcmd等
- **可视化工具**：VisualVM、JConsole、JProfiler、YourKit等
- **堆转储分析**：使用MAT（Memory Analyzer Tool）分析堆转储文件

### 3. 避免内存泄漏的最佳实践

- **及时释放不再使用的对象引用**
- **使用finally块关闭资源**
- **使用try-with-resources语法（JDK 7+）**
- **避免静态集合类无限制增长**
- **注意内部类和匿名内部类的使用**
- **使用WeakHashMap存储缓存数据**
- **ThreadLocal使用完毕调用remove方法**

## 十、垃圾回收的未来发展

### 1. 当前趋势

- **低延迟垃圾回收器**：如ZGC、Shenandoah
- **并发垃圾回收**：减少Stop-the-World时间
- **自适应垃圾回收**：根据应用行为自动调整
- **NUMA感知的垃圾回收**：针对多处理器系统优化

### 2. 未来可能的发展方向

- **更智能的GC算法**：结合机器学习预测对象生命周期
- **硬件辅助的GC**：利用特定硬件加速垃圾回收
- **更精细化的内存管理**：减少垃圾产生
- **无GC的Java**：探索不需要传统垃圾回收的内存管理方式

## 十一、总结

垃圾回收是Java平台的核心功能之一，它使开发者能够专注于业务逻辑而不是内存管理。随着Java技术的不断发展，垃圾回收器也在不断演进，从最初的Serial收集器到现代的G1、ZGC等，各种垃圾回收器都有其特定的应用场景。

理解垃圾回收的原理和不同收集器的特点，有助于我们根据应用需求选择合适的收集器和参数，避免内存泄漏，提高应用性能。同时，随着硬件和软件技术的发展，Java的垃圾回收机制也将继续演进，为我们提供更高效、更低延迟的内存管理方案。 