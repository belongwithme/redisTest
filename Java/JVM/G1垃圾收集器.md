@[TOC](G1垃圾收集器)
# 基础概念
## G1的全称是什么？它解决了什么问题？
G1(Garbage-First)名字直观反映了它的核心思想——优先回收垃圾最多的区域。
G1JDK 7引入并在JDK 9成为默认的垃圾收集器.
它解决了当时JVM垃圾收集器的两大痛点：
一是CMS收集器会产生内存碎片导致不得不Full GC；
二是大内存应用下，传统收集器停顿时间过长或不可控。

## G1相比CMS和Parallel GC有哪些优势？
CMS虽然并发标记减少了停顿，但它"标记-清除"的本质导致内存碎片，且无法控制回收的精确时间。
Parallel GC虽然吞吐量高，但"完整停顿"模式让大内存应用体验差。
G1结合了两者优点，通过Region化设计和增量回收，既能整理内存避免碎片，又能提供可预测的停顿时间，还支持大内存高并发应用。
G1与CMS、Parallel GC的优势:
- 相比CMS：G1整理内存避免碎片化；可预测的停顿时间；解决了CMS的浮动垃圾问题
- 相比Parallel GC：更短的停顿时间；增量回收设计；适合大内存应用


## Region概念是什么？如何组织内存？
G1将堆划分为大小相等的Region，一般为1MB-32MB。
不同Region可扮演不同角色(Eden、Survivor、Old等)。
这种设计使G1能进行更精细的内存管理，只回收部分Region，而不必回收整个内存区域，降低了停顿时间。
大对象用Humongous区域存储，跨越连续多个Region。
个人理解版:
G1打破了传统内存分代的物理隔离，将整个堆划分为均等大小的Region。
每个Region可在不同时期扮演不同角色(Eden、Survivor、Old)，形成逻辑分代而非物理分代。
这种设计带来极大灵活性：
- 可部分回收内存区域；
- 根据目标停顿时间动态调整回收范围；
- 对象晋升时无需大规模复制，直接改变Region身份即可。
- 它还专门为大对象设计了Humongous区域，避免了大对象分配和回收的性能问题。

## 工作原理
### G1收集器的回收过程是怎样的？
G1收集器的回收过程分为四个主要阶段：
- 年轻代GC(Young GC)、并发标记(Concurrent Marking)、混合回收(Mixed GC)和必要时的Full GC。
- Young GC只收集Eden和Survivor区；
- 并发标记确定活跃对象；
- Mixed GC同时回收年轻代和部分老年代区域；
- 当并发回收跟不上分配速度时，会触发Full GC。
个人理解版:
G1的回收过程体现了其"低延迟优先"的设计理念。
首先是Young GC，它类似传统的Minor GC但只涉及Eden和Survivor区的Region，因范围有限所以速度快。
随着老年代填充，触发并发标记周期，这个过程主要在后台运行不阻塞应用，标记出存活对象。
标记结束后进入Mixed GC阶段，这是G1的精髓所在 - 它会同时回收年轻代和部分价值最高(垃圾最多)的老年代Region，实现增量式回收。
这种"混合回收"机制让G1能在有限停顿时间内获得最大回收效益。
只有当并发回收速度跟不上分配速度时，才会触发Full GC作为最后手段。
### 什么是Remembered Set和Collection Set？
Remembered Set(RSet)是每个Region的辅助数据结构，记录了其他Region中的对象引用本Region中对象的关系，用于避免全堆扫描。
Collection Set(CSet)是一组将被回收的Region集合，由G1在GC时选定，通常包括所有Eden区、Survivor区和部分老年代Region。
个人理解版：
G1将堆分为许多Region后面临一个挑战：跨Region引用如何高效处理？
这就是Remembered Set(RSet)的作用。每个Region都有一个RSet，相当于"被引用记录表"，记录了哪些外部Region引用了本Region中的对象。
这种设计使G1能够只扫描必要的Region而非整个堆。
而Collection Set(CSet)则是G1智能选择策略的核心，它动态决定每次GC要回收哪些Region，在满足停顿时间目标的前提下，优先选择回收价值最高(垃圾最多)的区域，这正是"Garbage First"名称的由来。
### G1中的SATB是什么？解决了什么问题？
SATB(Snapshot-At-The-Beginning)是G1并发标记使用的一种算法.
在标记开始时对堆内存做一个逻辑快照，确保在并发标记过程中，已经存在的对象不会被错误回收。
通过SATB实现了对并发标记期间新增和修改引用的处理，避免了漏标问题。
个人理解版：
SATB(标记开始时快照)是G1解决并发标记准确性问题的关键技术。
并发标记面临的根本挑战是：当GC线程在标记的同时，应用线程还在修改引用关系，可能导致对象被错误回收。
SATB通过在标记开始时逻辑性地冻结堆的状态，结合写屏障技术，确保标记开始时所有可达对象在标记结束后仍被视为可达。
与CMS的增量更新相比，SATB可能保留一些已经变为垃圾的对象(浮动垃圾)，但避免了重新扫描整个根集合的停顿，总体上提供了更可预测的性能特征。SATB体现了G1"宁可错放，不可错杀"的保守策略，这些浮动垃圾会在下一轮GC中被清除。



# 深入理解
## Mixed GC如何选择要回收的老年代区域？
G1在Mixed GC中选择老年代区域基于"垃圾优先"原则，通过以下步骤：
- 并发标记阶段计算每个Region的活跃度(存活对象比例)；
- 构建Region回收价值排序表；
- 根据用户设定的停顿时间目标(-XX:MaxGCPauseMillis)，选择回收价值最高且能在目标时间内完成的老年代Region加入CSet。
通常会经过多次Mixed GC逐步回收所有需要回收的老年代区域。
个人理解版:
Mixed GC选择老年代区域的机制体现了G1"最大回收效益"的核心思想。
并发标记完成后，G1对每个Region进行"性价比"评估，计算出回收效率指标(垃圾占比、回收耗时预估)。
G1构建一个回收价值排序表，类似"投资回报率"排行榜，优先选择回收成本低且收益高的Region。这里的"成本"是回收时间，"收益"是释放空间。
基于用户设定的停顿预算，G1会贪心地选择能在时间预算内回收最多垃圾的Region组合。
这种"最大化有限时间内的回收价值"策略使G1特别适合大内存应用，它不必一次回收所有垃圾，而是分多次Mixed GC逐步回收，每次都尽可能提供最佳收益，直到回收到足够的空间或所有高价值区域都被回收。
## G1如何平衡吞吐量和停顿时间？
G1通过可调节的停顿时间目标和自适应算法平衡吞吐量与停顿时间。
它使用停顿预测模型(Pause Prediction Model)，基于历史GC数据，动态调整每次回收的Region数量。
用户可通过-XX:MaxGCPauseMillis设置停顿时间目标，G1会尽力满足，但较短的停顿目标可能导致吞吐量下降和更频繁的GC。
G1还提供-XX:GCPauseTimeInterval和-XX:G1MixedGCLiveThresholdPercent等参数来进一步微调这种平衡。
个人理解版:
G1平衡吞吐量和停顿时间的方式体现了其自适应特性。
传统收集器通常倾向一端：
要么停顿长但吞吐高(Parallel GC)，要么停顿短但吞吐低(CMS)。
G1打破这种非此即彼的局面，通过精细化的控制机制实现动态平衡。
它的核心是停顿预测模型，类似于自动驾驶中的路况预测系统，能根据历史GC表现、Region大小、对象分布等因素，预测回收任意Region组合的停顿时间。
用户只需设定停顿时间目标，G1会自动调整每次回收的范围和力度。
当系统负载较轻时，G1会回收更多Region提高吞吐量；
负载紧张时则减少回收范围确保响应性。
这种自适应能力是G1超越其前辈的关键，它能根据应用实时情况找到吞吐量和低延迟之间的最佳平衡点，无需手动频繁调优。
## G1的并发标记算法与CMS有何不同？
G1使用SATB(Snapshot-At-The-Beginning)算法，而CMS使用增量更新(Incremental Update)。
SATB在标记开始时对堆做逻辑快照，保证标记开始时活跃的对象不会被回收，即使后续成为垃圾；
而CMS只关注标记过程中新增引用
。SATB可能保留部分浮动垃圾，但避免了CMS重新标记阶段的全堆扫描，提供更稳定的停顿时间。
此外，G1并发标记与Region内存布局紧密结合，为混合回收提供信息，而CMS仅用于决定哪些对象可回收。
个人理解：
G1的SATB与CMS的增量更新代表了并发标记中两种不同的思路。
两者解决的都是标记过程中引用关系变化导致的对象可达性问题，但方式截然不同。
CMS采用"增量更新"，类似于追踪最新变化，只关注引用新增情况，标记开始后成为垃圾的对象仍会被回收；
而G1的SATB相当于"快照保护"，确保标记开始时可达的对象在标记结束时仍被视为可达，即使中途成为垃圾。
这种差异导致G1可能会多保留一些已成为垃圾的对象(下次GC再回收)，但能显著减少重新标记阶段的工作量和停顿时间。
更重要的是，SATB的实现使G1能够更精确地获取各Region的回收价值信息，这对后续Mixed GC的选择策略至关重要。
从实现上看，SATB通过写前屏障(pre-write barrier)记录引用变化，而CMS通过写后屏障(post-write barrier)，这也影响了两者在并发安全和性能开销上的差异。
# 对比分析
## ZGC与G1的对比分析？
ZGC(Z Garbage Collector)与G1的主要区别在于设计目标和实现技术。
ZGC是一种低延迟垃圾收集器，目标是在任何堆大小下将停顿时间控制在10ms以内，而G1的停顿通常在几十到几百毫秒。
ZGC采用了着色指针和读屏障技术，几乎所有操作都是并发的，包括并发的内存整理；
而G1只有部分并发，仍有不可忽视的停顿阶段。ZGC目前主要针对大内存(TB级)低延迟应用，但吞吐量可能略低于G1；
G1则在吞吐量和延迟之间取得了较好平衡。



个人理解:
ZGC与G1代表了JVM垃圾收集器的两个不同发展阶段和优化方向。
G1是"平衡型选手"，它改进了传统收集器的问题，在吞吐量和延迟间取得平衡，适应了服务器端大多数应用场景；
而ZGC是"极致低延迟选手"，它突破性地将GC停顿控制在10ms内，即使在TB级内存下也能保持这一特性。
技术上，G1采用的是传统的分代收集和部分并发策略，通过Region化实现增量回收；
ZGC则使用了全新的着色指针、读屏障技术，实现了几乎全并发的回收，包括标记、整理、移动对象等阶段。
G1需要为RSet等数据结构付出10%-20%的内存开销，而ZGC需要为指针染色预留部分地址位。
性能对比上，ZGC在低延迟方面绝对领先，适合响应时间敏感应用；
G1则在通用性和吞吐量上有优势，特别是在中等规模内存和多样化工作负载下表现更稳定。
从发展趋势看，ZGC代表了未来方向，但G1作为当前默认收集器，仍然是大多数Java应用的首选。
## 什么场景下G1不适用？应选择其他收集器？
G1作为一款平衡型收集器，虽然适应性强，但并非全能，在某些特定场景下应考虑替代方案：
- 极低延迟场景：金融交易、高频交易、游戏服务器等对延迟极其敏感的应用，G1的几十毫秒停顿可能仍然不可接受，此时应选择ZGC或Shenandoah，它们能将停顿控制在个位数毫秒级。
- 计算密集型批处理：对于离线数据分析、批量处理等任务，系统吞吐量远比响应时间重要，G1为低延迟付出的吞吐量代价可能不值得，Parallel GC的全力并行回收可提供最大吞吐量。
- 资源受限环境：G1的各种精细化控制机制和数据结构(RSet、预测模型等)带来了额外内存和CPU开销，在容器化环境、边缘计算设备等资源紧张场景，这些开销比例可能过高，传统的Serial或Parallel收集器反而更高效。
- 特定内存模式应用：某些应用有着非常特殊的内存使用模式，如大量大对象分配或极高的对象存活率，G1的Region设计和复杂决策逻辑可能不如专门优化的收集器高效。
- JVM语言多样性：对于某些JVM上的非Java语言(如Scala、Clojure)，其内存分配模式可能与Java有显著差异，G1的优化假设可能不完全适用，需要针对性选择或调优其他收集器。