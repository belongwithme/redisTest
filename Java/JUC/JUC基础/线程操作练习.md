面几个练习题，从易到难，帮助巩固 `start()`, `sleep()`, `join()`, `interrupt()` 等核心操作的用法。

---

## 练习 1：创建和启动线程

*   **目标**：练习使用两种主要方式创建和启动线程，观察并发执行的基本现象。
*   **要求**：
    1.  创建一个类 `MyThreadTask` 继承自 `Thread`，重写 `run()` 方法，在方法中打印 5 次当前线程的名字和循环次数（例如："Thread-MyThreadTask: 0", "Thread-MyThreadTask: 1", ...）。
    2.  创建一个类 `MyRunnableTask` 实现 `Runnable` 接口，实现 `run()` 方法，在方法中打印 5 次当前线程的名字和循环次数（例如："Thread-MyRunnableTask: 0", ...）。
    3.  在 `main` 方法中：
        *   创建并启动 2 个 `MyThreadTask` 线程实例。
        *   创建 2 个 `MyRunnableTask` 任务实例，然后用它们分别创建并启动 2 个 `Thread` 实例。
        *   给每个线程设置一个有意义的名字。
        *   观察控制台的输出，注意不同线程的打印语句是如何交错执行的。

**答案:**
```java
import java.util.concurrent.TimeUnit; // 用于简化 sleep

// 方式一：继承 Thread 类
class MyThreadTask extends Thread {
    public MyThreadTask(String name) {
        super(name); // 调用父类构造函数设置线程名称
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("Thread [" + Thread.currentThread().getName() + "]: count " + i);
            // 短暂休眠，让其他线程有机会执行，更容易看到交错效果
            try {
                TimeUnit.MILLISECONDS.sleep(10);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println("Thread [" + Thread.currentThread().getName() + "] finished.");
    }
}

// 方式二：实现 Runnable 接口
class MyRunnableTask implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("Runnable Task in Thread [" + Thread.currentThread().getName() + "]: count " + i);
            try {
                TimeUnit.MILLISECONDS.sleep(10);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
         System.out.println("Runnable Task in Thread [" + Thread.currentThread().getName() + "] finished.");
    }
}

public class Exercise1 {
    public static void main(String[] args) {
        System.out.println("Main thread started.");

        // 创建并启动 MyThreadTask 实例
        MyThreadTask threadTask1 = new MyThreadTask("MyThread-1");
        MyThreadTask threadTask2 = new MyThreadTask("MyThread-2");
        threadTask1.start();
        threadTask2.start();

        // 创建 MyRunnableTask 实例
        MyRunnableTask runnableTask1 = new MyRunnableTask();
        MyRunnableTask runnableTask2 = new MyRunnableTask();

        // 使用 MyRunnableTask 创建并启动 Thread 实例
        Thread runnableThread1 = new Thread(runnableTask1, "MyRunnableThread-1");
        Thread runnableThread2 = new Thread(runnableTask2, "MyRunnableThread-2");
        runnableThread1.start();
        runnableThread2.start();

        System.out.println("Main thread finished starting other threads.");
        // main 线程会继续执行，可能比子线程先结束
    }
}
```

---

## 练习 2：使用 `Thread.sleep()`

*   **目标**：理解 `sleep()` 的作用，即让当前线程暂停执行一段时间。
*   **要求**：
    1.  修改练习 1 中的 `run()` 方法（两个类都需要修改）。
    2.  在每次打印循环次数后，让当前线程调用 `Thread.sleep()` 随机休眠一段时间（例如 100 到 500 毫秒之间）。可以使用 `java.util.Random` 类生成随机数。
    3.  注意处理 `InterruptedException`（可以简单打印异常信息或重新设置中断状态）。
    4.  再次运行 `main` 方法，观察线程的执行顺序与之前有何不同，执行的总时间是否变长了。

**答案:**
```java
import java.util.Random;
import java.util.concurrent.TimeUnit;

// 修改 MyThreadTask
class MyThreadTaskWithSleep extends Thread {
    private Random random = new Random();

    public MyThreadTaskWithSleep(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("Thread [" + getName() + "]: count " + i);
            try {
                // 随机休眠 100 到 500 毫秒
                int sleepTime = 100 + random.nextInt(401); // random.nextInt(401) -> [0, 400]
                System.out.println("Thread [" + getName() + "] sleeping for " + sleepTime + " ms...");
                TimeUnit.MILLISECONDS.sleep(sleepTime);
            } catch (InterruptedException e) {
                System.out.println("Thread [" + getName() + "] was interrupted during sleep.");
                Thread.currentThread().interrupt(); // 重新设置中断状态
                // 决定是否退出循环
                 break;
            }
        }
         System.out.println("Thread [" + getName() + "] finished.");
    }
}

// 修改 MyRunnableTask
class MyRunnableTaskWithSleep implements Runnable {
     private Random random = new Random();

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        for (int i = 0; i < 5; i++) {
             System.out.println("Runnable Task in Thread [" + threadName + "]: count " + i);
            try {
                int sleepTime = 100 + random.nextInt(401);
                System.out.println("Runnable Task in Thread [" + threadName + "] sleeping for " + sleepTime + " ms...");
                TimeUnit.MILLISECONDS.sleep(sleepTime);
            } catch (InterruptedException e) {
                 System.out.println("Runnable Task in Thread [" + threadName + "] was interrupted during sleep.");
                Thread.currentThread().interrupt();
                break;
            }
        }
        System.out.println("Runnable Task in Thread [" + threadName + "] finished.");
    }
}


public class Exercise2 {
    public static void main(String[] args) {
         System.out.println("Main thread started.");

        MyThreadTaskWithSleep threadTask1 = new MyThreadTaskWithSleep("MyThread-Sleep-1");
        MyThreadTaskWithSleep threadTask2 = new MyThreadTaskWithSleep("MyThread-Sleep-2");
        threadTask1.start();
        threadTask2.start();

        MyRunnableTaskWithSleep runnableTask1 = new MyRunnableTaskWithSleep();
        MyRunnableTaskWithSleep runnableTask2 = new MyRunnableTaskWithSleep();

        Thread runnableThread1 = new Thread(runnableTask1, "MyRunnableThread-Sleep-1");
        Thread runnableThread2 = new Thread(runnableTask2, "MyRunnableThread-Sleep-2");
        runnableThread1.start();
        runnableThread2.start();

        System.out.println("Main thread finished starting other threads.");
    }
}
```

---

## 练习 3：使用 `thread.join()`

*   **目标**：学习如何让一个线程等待另一个线程执行完成。
*   **要求**：
    1.  创建一个 `WorkerThread` 类（可以是继承 `Thread` 或实现 `Runnable`），其 `run()` 方法模拟一个耗时任务（例如，循环计算或者 `sleep` 几秒钟），并在任务开始和结束时打印消息。
    2.  在 `main` 方法中：
        *   创建并启动 3 个 `WorkerThread` 实例。
        *   在启动所有 worker 线程后，`main` 线程需要等待**所有**这 3 个 worker 线程都执行完毕。使用 `join()` 方法来实现这一点。
        *   当所有 worker 线程都结束后，`main` 线程打印一条 "所有工作线程已完成！" 的消息。

**答案:**
```java
import java.util.concurrent.TimeUnit;

class WorkerThread implements Runnable {
    private String name;
    private long workDurationMillis;

    public WorkerThread(String name, long workDurationMillis) {
        this.name = name;
        this.workDurationMillis = workDurationMillis;
    }

    @Override
    public void run() {
        System.out.println("Worker [" + name + "] started.");
        try {
            System.out.println("Worker [" + name + "] working for " + workDurationMillis + " ms...");
            TimeUnit.MILLISECONDS.sleep(workDurationMillis);
        } catch (InterruptedException e) {
             System.out.println("Worker [" + name + "] was interrupted.");
             Thread.currentThread().interrupt();
        }
        System.out.println("Worker [" + name + "] finished.");
    }
}

public class Exercise3 {
    public static void main(String[] args) {
        System.out.println("Main thread started.");

        Thread worker1 = new Thread(new WorkerThread("Worker-1", 2000)); // 工作 2 秒
        Thread worker2 = new Thread(new WorkerThread("Worker-2", 3000)); // 工作 3 秒
        Thread worker3 = new Thread(new WorkerThread("Worker-3", 1500)); // 工作 1.5 秒

        worker1.start();
        worker2.start();
        worker3.start();

        System.out.println("Main thread waiting for workers to finish...");

        try {
            // 等待每个 worker 线程结束
            worker1.join();
            System.out.println("Worker-1 finished, joining Worker-2...");
            worker2.join();
             System.out.println("Worker-2 finished, joining Worker-3...");
            worker3.join();
             System.out.println("Worker-3 finished.");
        } catch (InterruptedException e) {
            System.out.println("Main thread was interrupted while waiting.");
            Thread.currentThread().interrupt();
        }

        System.out.println("所有工作线程已完成！ Main thread finished.");
    }
}
```

---

## 练习 4：处理线程中断 `interrupt()`

*   **目标**：练习如何优雅地响应中断请求。
*   **要求**：
    1.  创建一个 `LongRunningTask` 类实现 `Runnable`。
    2.  在其 `run()` 方法中，实现一个长时间运行的循环（例如，循环很多次或者使用 `while(true)`）。
    3.  在循环体内部：
        *   **方式一（检查中断标志）**：在循环条件或循环体内，使用 `Thread.currentThread().isInterrupted()` 检查中断状态。如果发现被中断，打印一条消息并**退出循环**（结束 `run` 方法）。在循环中可以加入短暂的 `sleep`（例如 100 毫秒）来模拟工作并降低 CPU 占用，但主要依靠 `isInterrupted()` 来退出。
        *   **方式二（响应 `InterruptedException`）**：让线程在循环中调用 `Thread.sleep()`（例如 `sleep(500)`）。在 `catch (InterruptedException e)` 块中，打印被中断的消息，并**退出循环**。**记住**，捕获 `InterruptedException` 后需要**重新设置中断状态** (`Thread.currentThread().interrupt()`) 是一个好习惯，除非你确定当前就是处理中断的最终层级。
    4.  在 `main` 方法中：
        *   创建并启动一个运行 `LongRunningTask` 的线程。
        *   让 `main` 线程 `sleep` 一小段时间（例如 3 秒）。
        *   调用任务线程的 `interrupt()` 方法来请求中断。
        *   （可选）调用任务线程的 `join()` 方法等待它真正结束。
        *   观察任务线程是否按预期停止了执行。

**答案:**
```java
import java.util.concurrent.TimeUnit;

// 方式一：检查中断标志
class LongRunningTaskCheckInterrupt implements Runnable {
    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        System.out.println("Task [" + threadName + "] started (checking interrupt flag).");
        long counter = 0;
        // 使用 isInterrupted() 检查，它不清除中断状态
        while (!Thread.currentThread().isInterrupted()) {
            counter++;
            if (counter % 100000000 == 0) { // 打印进度，避免刷屏
                 System.out.println("Task [" + threadName + "] still running (checked flag)... counter=" + counter);
            }
            // 可以加入短暂休眠，模拟工作并降低CPU占用，但中断主要靠标志检查
            // try {
            //     TimeUnit.MILLISECONDS.sleep(1);
            // } catch (InterruptedException e) {
            //     // 如果在 sleep 中被中断，也会抛异常，也需要处理
            //     System.out.println("Task [" + threadName + "] interrupted during optional sleep!");
            //     Thread.currentThread().interrupt(); // 重新设置状态
            //     break; // 退出循环
            // }
        }
        // 循环结束，说明检测到了中断标志
        System.out.println("Task [" + threadName + "] detected interrupt flag, stopping. Final counter=" + counter);
        System.out.println("Task [" + threadName + "] finished.");
    }
}

// 方式二：响应 InterruptedException
class LongRunningTaskRespondInterrupt implements Runnable {
    @Override
    public void run() {
         String threadName = Thread.currentThread().getName();
         System.out.println("Task [" + threadName + "] started (responding to InterruptedException).");
         long counter = 0;
         try {
             while (true) { // 依赖 sleep 抛出异常来中断
                 counter++;
                 if (counter % 5 == 0) { // 每 5 次打印一次
                    System.out.println("Task [" + threadName + "] still running (sleep)... counter=" + counter);
                 }
                 // sleep 会检查中断状态，如果被中断则抛出 InterruptedException
                 TimeUnit.MILLISECONDS.sleep(500);
             }
         } catch (InterruptedException e) {
             // 捕获中断异常
             System.out.println("Task [" + threadName + "] caught InterruptedException, stopping. Final counter=" + counter);
             // 重要：重新设置中断状态，通知上层调用者发生过中断
             Thread.currentThread().interrupt();
         }
         System.out.println("Task [" + threadName + "] finished.");
    }
}


public class Exercise4 {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("Main thread started.");

        // 测试方式一
        System.out.println("\n--- Testing LongRunningTaskCheckInterrupt ---");
        Thread taskThread1 = new Thread(new LongRunningTaskCheckInterrupt(), "CheckInterruptTask");
        taskThread1.start();
        TimeUnit.SECONDS.sleep(2); // 让任务运行 2 秒
        System.out.println("Main thread interrupting CheckInterruptTask...");
        taskThread1.interrupt(); // 发送中断请求
        taskThread1.join(); // 等待任务线程结束
        System.out.println("CheckInterruptTask thread joined.");
        System.out.println("CheckInterruptTask final interrupted status: " + taskThread1.isInterrupted());


         // 测试方式二
        System.out.println("\n--- Testing LongRunningTaskRespondInterrupt ---");
        Thread taskThread2 = new Thread(new LongRunningTaskRespondInterrupt(), "RespondInterruptTask");
        taskThread2.start();
        TimeUnit.SECONDS.sleep(3); // 让任务运行 3 秒
        System.out.println("Main thread interrupting RespondInterruptTask...");
        taskThread2.interrupt(); // 发送中断请求
        taskThread2.join(); // 等待任务线程结束
        System.out.println("RespondInterruptTask thread joined.");
        // 因为在 catch 块中调用了 Thread.currentThread().interrupt()，所以最终状态应该是 true
        System.out.println("RespondInterruptTask final interrupted status: " + taskThread2.isInterrupted());


        System.out.println("\nMain thread finished.");
    }
}
```

---

## 练习 5：综合应用（可选挑战）

*   **目标**：结合使用多种线程操作解决一个稍微复杂点的问题。
*   **要求**：
    1.  模拟一个简单的下载任务。
    2.  创建一个 `Downloader` 线程，它模拟下载过程：循环 10 次，每次打印 "正在下载... 第 x%"，并在每次打印后 `sleep(300)` 毫秒。在循环内部检查中断状态，如果被中断则打印 "下载被取消！" 并退出。下载完成后打印 "下载完成！"。
    3.  在 `main` 方法中：
        *   启动 `Downloader` 线程。
        *   启动另一个 `TimeoutWatcher` 线程（可以使用 Lambda 表达式创建）。这个线程 `sleep` 2 秒钟。如果在 2 秒内 `Downloader` 线程还没有结束 (`isAlive()` 可以判断)，`TimeoutWatcher` 就调用 `downloader.interrupt()` 来取消下载。
        *   `main` 线程使用 `downloader.join()` 等待下载线程结束（无论是因为完成还是被取消）。
        *   最后根据 `downloader` 线程是否还存活（或者通过其他标志）来判断下载是成功完成还是被取消了。

**答案:**
```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean; // 用于线程间通信的标志

class Downloader implements Runnable {
    // 使用 AtomicBoolean 作为完成标志，是线程安全的
    private final AtomicBoolean completedSuccessfully = new AtomicBoolean(false);
    private final AtomicBoolean cancelled = new AtomicBoolean(false);

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        System.out.println("[" + threadName + "] Download started.");
        try {
            for (int i = 0; i <= 100; i += 10) {
                // 检查中断状态
                if (Thread.currentThread().isInterrupted()) {
                    // 如果在循环开始或中间被中断
                    cancelled.set(true);
                    System.out.println("\n[" + threadName + "] Download interrupted (checked flag) at " + i + "%!");
                    // 清理操作（如果需要）
                    return; // 退出 run 方法
                }

                System.out.print("[" + threadName + "] Downloading... " + i + "% ");
                // 模拟下载耗时
                TimeUnit.MILLISECONDS.sleep(300);
            }
            // 循环正常完成
            System.out.println("\n[" + threadName + "] Download completed successfully!");
            completedSuccessfully.set(true);

        } catch (InterruptedException e) {
            // 如果在 sleep 时被中断
             cancelled.set(true);
             System.out.println("\n[" + threadName + "] Download interrupted during sleep!");
             // 不需要再次调用 interrupt()，因为上游 TimeoutWatcher 就是中断源
             // Thread.currentThread().interrupt(); // 如果希望保持中断状态，可以加这行
        } finally {
            System.out.println("[" + threadName + "] Exiting run method.");
        }
    }

    public boolean isCompletedSuccessfully() {
        return completedSuccessfully.get();
    }

     public boolean isCancelled() {
        return cancelled.get();
    }
}

public class Exercise5 {
    public static void main(String[] args) {
        System.out.println("Main thread started.");

        Downloader downloaderTask = new Downloader();
        Thread downloaderThread = new Thread(downloaderTask, "Downloader");

        // 创建超时监控线程
        Thread timeoutWatcherThread = new Thread(() -> {
            String watcherName = Thread.currentThread().getName();
            System.out.println("[" + watcherName + "] Started, will interrupt downloader after 2 seconds if still running.");
            try {
                TimeUnit.SECONDS.sleep(2); // 等待 2 秒

                // 检查下载线程是否还在运行
                if (downloaderThread.isAlive()) {
                    System.out.println("[" + watcherName + "] Downloader is still running after 2 seconds. Interrupting...");
                    downloaderThread.interrupt(); // 发送中断请求
                } else {
                     System.out.println("[" + watcherName + "] Downloader finished within 2 seconds.");
                }
            } catch (InterruptedException e) {
                 System.out.println("[" + watcherName + "] was interrupted.");
                 Thread.currentThread().interrupt();
            }
             System.out.println("[" + watcherName + "] Finished.");
        }, "TimeoutWatcher");

        // 启动下载线程和监控线程
        downloaderThread.start();
        timeoutWatcherThread.start();

        // Main 线程等待下载线程结束（无论完成或被取消）
        try {
            System.out.println("[Main] Waiting for downloader thread to join...");
            downloaderThread.join();
            System.out.println("[Main] Downloader thread joined.");
        } catch (InterruptedException e) {
             System.out.println("[Main] Interrupted while waiting for downloader.");
             Thread.currentThread().interrupt();
        }

        // 判断最终结果
        if (downloaderTask.isCompletedSuccessfully()) {
            System.out.println("[Main] Final Status: Download Completed Successfully!");
        } else if (downloaderTask.isCancelled()) {
             System.out.println("[Main] Final Status: Download Was Cancelled/Interrupted!");
        } else {
            // 可能的情况：线程异常退出等（本例中不太可能）
             System.out.println("[Main] Final Status: Download did not complete or cancel as expected.");
        }

         System.out.println("Main thread finished.");
    }
}
```

---

## 练习 6：理解竞态条件 (Race Condition)

*   **目标**：亲身体验多线程访问共享资源时可能出现的问题，理解为何需要同步。
*   **要求**：
    1.  创建一个类 `Counter`，它有一个实例变量 `private int count = 0;` 和一个 `increment()` 方法，该方法执行 `count++`。再添加一个 `getCount()` 方法返回 `count` 的值。
    2.  创建一个 `Runnable` 任务，在其 `run()` 方法中，循环调用 `Counter` 对象的 `increment()` 方法 10000 次。
    3.  在 `main` 方法中：
        *   创建一个共享的 `Counter` 实例。
        *   创建并启动 10 个线程，每个线程都执行上述的 `Runnable` 任务（操作同一个 `Counter` 实例）。
        *   使用 `join()` 等待所有这 10 个线程都执行完毕。
        *   打印最终 `counter.getCount()` 的值。
    4.  **思考与观察**：
        *   预期的最终 `count` 值应该是多少？ (10 * 10000 = 100000)
        *   多次运行程序，观察实际打印的最终 `count` 值是多少？它是否总是等于预期值？为什么会出现这种情况？（提示：`count++` 不是原子操作）

答案:
```java
class Counter {
    private int count = 0;
    public void increment() { count++; }
    public int getCount() { return count; }
}

public class demo {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        // Runnable 任务，确保循环能正确执行 10000 次
        Runnable runnable = () -> { // 使用 Lambda 表达式简化
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
        };
        // 或者你的原始 Runnable 修改后：
        /*
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                // 使用 for 循环确保次数正确
                for (int n = 0; n < 10000; n++) {
                    counter.increment();
                }
            }
        };
        */


        int numThreads = 10;
        Thread[] threads = new Thread[numThreads]; // 创建一个数组来存储线程引用

        // 第一个循环：启动所有线程
        System.out.println("Starting all threads...");
        for (int i = 0; i < numThreads; i++) {
            threads[i] = new Thread(runnable);
            threads[i].start(); // 仅仅启动，不等待
        }

        // 第二个循环：等待所有线程结束
        System.out.println("Waiting for all threads to finish...");
        for (int i = 0; i < numThreads; i++) {
            threads[i].join(); // 在所有线程都启动后再等待它们
        }

        System.out.println("All threads finished.");
        System.out.println("Expected final count: " + (numThreads * 10000));
        System.out.println("Actual final count:   " + counter.getCount()); // 现在应该能看到小于预期值的情况了
    }
}
```

思考与观察解答：
预期值：100000 (10 个线程，每个线程增加 10000 次)。
实际值：多次运行会发现，实际打印的 count 值几乎总是小于 100000，并且每次运行的结果可能都不同。
原因：count++ 这个操作看起来简单，但它在字节码层面（甚至在 CPU 指令层面）通常包含三个步骤：
读取 count 的当前值到工作内存（或寄存器）。
将读取到的值加 1。
将计算后的新值写回 count 变量（写回主内存）。
由于这三个步骤不是原子的，多个线程并发执行 increment() 时，可能会发生以下情况（竞态条件）：
线程 A 读取 count (假设为 5)。
线程 B 也读取 count (也读取到 5)。
线程 A 计算 5 + 1 = 6，并将 6 写回 count。
线程 B 计算 5 + 1 = 6，并将 6 写回 count。
虽然两个线程都执行了 increment()，但 count 最终只增加了 1（变成了 6），而不是期望的增加 2（变成 7）。这种读写冲突导致了最终结果丢失了一部分增量。
---

## 练习 7：使用 synchronized 解决竞态条件

*   **目标**：学习使用 `synchronized` 关键字保护共享资源，解决练习 6 中出现的问题。
*   **要求**：
    1.  基于练习 6 的代码。
    2.  修改 `Counter` 类的 `increment()` 方法和 `getCount()` 方法（或者只修改 `increment`，取决于你认为哪里需要保护），使用 `synchronized` 关键字来保证对 `count` 变量访问的原子性和可见性。你可以选择同步整个方法，或者使用 `synchronized(this)` 代码块。
    3.  再次运行 `main` 方法多次。
    4.  **观察**：现在最终的 `count` 值是否总是等于预期值 100000？ `synchronized` 是如何解决问题的？


答案:
```java
// 修改 Counter 类
class SynchronizedCounter {
    private int count = 0;

    // 使用 synchronized 修饰实例方法，锁是 this 对象
    public synchronized void increment() {
        count++; // 现在这个操作是原子的，且对其他线程可见
    }

    // 读取操作最好也加上 synchronized，保证可见性
    // (虽然在这个特定例子里，由于 join() 的 happens-before 保证，
    //  即使 getCount() 不加 synchronized 可能也能看到正确结果，
    //  但加锁是更严谨的做法)
    public synchronized int getCount() {
        return count;
    }

    // 或者使用同步代码块 (效果相同)
    /*
    private final Object lock = new Object(); // 可以创建一个专门的锁对象
    public void increment() {
        synchronized (this) { // 或 synchronized(lock)
            count++;
        }
    }
    public int getCount() {
        synchronized (this) { // 或 synchronized(lock)
            return count;
        }
    }
    */
}
```
现在多次运行程序，最终的 count 值总是等于 100000。
synchronized 如何解决问题：
互斥性/原子性：synchronized 关键字保证了 increment() 方法（或同步块）在同一时刻只能被一个线程执行。当一个线程进入 increment() 时，它会获取 sharedCounter 对象（this）的锁，其他线程如果想进入 increment()（或同一个对象的其他 synchronized 方法/块），就必须等待该线程释放锁。这使得 count++ 的“读-改-写”三个步骤作为一个不可分割的原子单元执行，不会被其他线程干扰。
可见性：当一个线程退出 synchronized 方法/块（释放锁）时，JMM 会保证它对共享变量（count）的修改刷新到主内存。当另一个线程进入同一个 synchronized 方法/块（获取锁）时，JMM 会保证它从主内存读取最新的共享变量值。这确保了一个线程对 count 的修改对后续获取锁的线程是可见的。
---

## 练习 8：使用 volatile 实现状态标志

*   **目标**：理解 `volatile` 在保证可见性方面的作用，适用于简单的状态控制。
*   **要求**：
    1.  创建一个 `Worker` 类实现 `Runnable`。
    2.  `Worker` 类有一个 `private volatile boolean running = true;` 实例变量。
    3.  `run()` 方法包含一个 `while(running)` 循环，在循环中打印 "Worker is running..." 并短暂 `sleep`（例如 200 毫秒）。
    4.  `Worker` 类提供一个 `public void stopWorker()` 方法，该方法将 `running` 设置为 `false`。
    5.  在 `main` 方法中：
        *   创建 `Worker` 实例。
        *   创建并启动一个线程来运行 `Worker` 任务。
        *   让 `main` 线程 `sleep` 1 秒钟。
        *   调用 `worker.stopWorker()` 方法。
        *   观察 worker 线程是否能够正常停止。（提示：如果没有 `volatile`，可能会因为可见性问题导致 worker 线程无法看到 `running` 变为 `false` 而一直循环下去）。

答案:
```java
import java.util.concurrent.TimeUnit;

class VolatileWorker implements Runnable {
    // 使用 volatile 保证可见性
    private volatile boolean running = true;

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        System.out.println("[" + threadName + "] Worker started.");
        while (running) { // 读取 volatile 变量
            System.out.println("[" + threadName + "] Worker is running...");
            try {
                // 短暂休眠，模拟工作，也让主线程有机会执行 stopWorker
                TimeUnit.MILLISECONDS.sleep(200);
            } catch (InterruptedException e) {
                // 如果在 sleep 时被中断，也应该停止
                System.out.println("[" + threadName + "] Worker interrupted during sleep, stopping.");
                // 不需要设置 running = false，因为中断也意味着要停止
                Thread.currentThread().interrupt(); // 保持中断状态
                break; // 退出循环
            }
        }
        System.out.println("[" + threadName + "] Worker stopped.");
    }

    public void stopWorker() {
        System.out.println("[Main thread] Requesting worker to stop...");
        this.running = false; // 写入 volatile 变量
    }
}

public class Exercise8 {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("Main thread started.");

        VolatileWorker workerTask = new VolatileWorker();
        Thread workerThread = new Thread(workerTask, "VolatileWorkerThread");
        workerThread.start();

        // 让 worker 线程运行 1 秒
        TimeUnit.SECONDS.sleep(1);

        // 从主线程请求停止 worker 线程(注意这个方法是在主线程里面被调用的!)
        workerTask.stopWorker();

        // (可选) 等待 worker 线程真正结束
        workerThread.join();
        System.out.println("Worker thread joined.");

        System.out.println("Main thread finished.");
    }
}
```
运行程序，会看到 worker 线程打印 "Worker is running..." 几次后，在 main 线程调用 stopWorker() 将 running 设置为 false 后，worker 线程能够检测到 running 值的变化，退出 while 循环，并打印 "Worker stopped."。
volatile 的作用：
当 main 线程执行 workerTask.stopWorker()，写入 running = false; 时，volatile 关键字保证了这个新值 (false) 会被立即强制写回主内存。
当 workerThread 在下一次循环判断 while(running) 时，volatile 关键字保证了它会强制从主内存中读取 running 的最新值，而不是使用自己工作内存中可能存在的旧值 (true)。
这样就确保了 main 线程对 running 标志的修改能够及时被 workerThread 看到，从而实现了线程的正常停止。
如果没有 volatile，workerThread 可能会因为 CPU 缓存等原因一直读取到旧的 running 值 (true)，导致无法停止（活性问题）。
---


## 练习 9：使用 wait() / notify() 实现生产者-消费者

*   **目标**：学习使用 `Object` 的 `wait()`, `notify()` (或 `notifyAll()`) 方法进行线程间通信，实现经典的生产者-消费者模式。
*   **要求**：
    1.  创建一个缓冲区类 `Buffer`（例如，使用 `LinkedList` 或 `ArrayDeque` 作为内部存储），它有固定的大小（比如 5）。
    2.  `Buffer` 类需要两个方法：
        *   `produce(int item)`: 向缓冲区添加物品。如果缓冲区已满，生产者线程需要调用 `wait()` 等待。添加成功后，需要调用 `notifyAll()` 唤醒可能在等待的消费者线程。
        *   `consume()`: 从缓冲区取出物品。如果缓冲区为空，消费者线程需要调用 `wait()` 等待。取出成功后，需要调用 `notifyAll()` 唤醒可能在等待的生产者线程。
    3.  **重要**：`produce` 和 `consume` 方法都需要使用 `synchronized` 关键字（或同步块）来保护对缓冲区的访问以及 `wait/notify` 的调用（因为 `wait/notify` 必须在同步块/方法内调用）。 `wait()` 的调用通常放在 `while` 循环中检查条件，以防止虚假唤醒 (spurious wakeup)。
    4.  创建生产者 `Producer` 线程（实现 `Runnable`），循环生产物品（例如从 0 开始递增的整数）并放入 `Buffer`。
    5.  创建消费者 `Consumer` 线程（实现 `Runnable`），循环从 `Buffer` 取出物品并打印。
    6.  在 `main` 方法中：
        *   创建共享的 `Buffer` 实例。
        *   启动一个或多个生产者线程。
        *   启动一个或多个消费者线程。
        *   观察生产者和消费者是否能正确地交替工作，缓冲区是否不会溢出或空等。
答案:
```java
public class exercise9 {
    public static void main(String[] args) {
        // int n = 0; // 'n' 在这里声明并在匿名内部类中使用，会导致问题

        Buffer buffer = new Buffer(5); // *** 指定容量 ***

        // --- 生产者任务 ---
        Runnable ProRunnable = new Runnable() {
            private int itemToProduce = 0; // 每个生产者维护自己的生产序列

            @Override
            public void run() {
                try { // *** 最好加上 try-catch 处理中断 ***
                    while (true) { // 或者有明确的生产数量
                        buffer.produce(itemToProduce);
                        System.out.println("Producer [" + Thread.currentThread().getName() + "] Produced: " + itemToProduce);
                        itemToProduce++; // 生产下一个
                        // 模拟生产耗时
                        Thread.sleep((long)(Math.random() * 500)); // *** 加入随机休眠方便观察 ***
                    }
                } catch (InterruptedException e) {
                    System.out.println("Producer [" + Thread.currentThread().getName() + "] interrupted.");
                    Thread.currentThread().interrupt(); // 重新设置中断状态
                }
            }
        };

        // --- 消费者任务 ---
        Runnable ConRunnable = new Runnable() {
            @Override
            public void run() {
                try {
                    while (true) { // 或者有明确的消费数量
                        int consumedItem = buffer.consume();
                        System.out.println("Consumer [" + Thread.currentThread().getName() + "] Consumed: " + consumedItem);
                        // 模拟消费耗时
                         Thread.sleep((long)(Math.random() * 1000)); // *** 加入随机休眠方便观察 ***
                    }
                // } catch (InterruptedException e) { // *** 捕获中断 ***
                //    System.out.println("Consumer [" + Thread.currentThread().getName() + "] interrupted.");
                //    Thread.currentThread().interrupt();
                } catch (InterruptedException e) { // 你的原始写法，也会中断线程
                    // throw new RuntimeException(e);
                    System.out.println("Consumer [" + Thread.currentThread().getName() + "] interrupted via RuntimeException propagation.");
                     Thread.currentThread().interrupt(); // 设置中断状态
                }
            }
        };

        // --- 启动线程 ---
        Thread ProThread1 = new Thread(ProRunnable, "Producer-1"); // *** 给线程命名 ***
        // Thread ProThread2 = new Thread(ProRunnable, "Producer-2"); // 可以启动多个生产者
        Thread ConThread1 = new Thread(ConRunnable, "Consumer-1");
        Thread ConThread2 = new Thread(ConRunnable, "Consumer-2"); // 可以启动多个消费者

        ProThread1.start();
        // ProThread2.start();
        ConThread1.start();
        ConThread2.start();

        // *** 注意：这个 main 方法会很快结束，但生产者消费者线程会继续运行 (因为是无限循环)
        // 实际应用中需要考虑如何优雅地停止这些线程 ***

    }
}

class Buffer{
    private final int capacity; // *** 使用 final 明确容量不变 ***
    private final LinkedList<Integer> bufferList; // *** 指定泛型类型 ***
    // private final Object lock = new Object(); // 可以用 this 作为锁，或者单独对象

    // *** 添加构造函数来设置容量 ***
    public Buffer(int capacity) {
        this.capacity = capacity;
        this.bufferList = new LinkedList<>();
    }


    public synchronized void produce(int item) throws InterruptedException { // *** 声明 InterruptedException ***
        // *** 1. 必须检查缓冲区是否已满 ***
        // *** 2. 必须使用 while 循环检查条件，防止虚假唤醒 ***
        while (bufferList.size() == capacity) {
             System.out.println("Producer [" + Thread.currentThread().getName() + "] Buffer FULL, waiting...");
             wait(); // 缓冲区满，等待并释放锁
        }
        // 缓冲区未满
        bufferList.add(item);
        // System.out.println("Producer [" + Thread.currentThread().getName() + "] Produced: " + item + " (Size: " + bufferList.size() + ")"); // 移到 Runnable 中打印

        // *** 3. 添加物品后必须通知等待的消费者 ***
        notifyAll(); // 唤醒所有等待的线程（生产者或消费者）
    }

    public synchronized int consume() throws InterruptedException {
        // *** 4. 必须使用 while 循环检查条件，防止虚假唤醒 ***
        while(bufferList.size() == 0){ // 或者 bufferList.isEmpty()
             System.out.println("Consumer [" + Thread.currentThread().getName() + "] Buffer EMPTY, waiting...");
             wait(); // 缓冲区空，等待并释放锁
        }
        // 缓冲区非空
        int item = bufferList.remove(); // remove() 默认移除第一个元素
        // System.out.println("Consumer [" + Thread.currentThread().getName() + "] Consumed: " + item + " (Size: " + bufferList.size() + ")"); // 移到 Runnable 中打印

        // *** 5. 取出物品后必须通知等待的生产者 ***
        notifyAll(); // 唤醒所有等待的线程
        return item;
    }
}
```
---

## 练习 10：使用 ExecutorService (线程池)

*   **目标**：学习使用 Java 标准库提供的线程池来管理和执行任务，避免手动创建线程。
*   **要求**：
    1.  回顾练习 6 或 7 中的 `Runnable` 任务（给 `Counter` 递增的任务）。
    2.  在 `main` 方法中：
        *   不再手动创建 10 个 `Thread` 实例。
        *   使用 `Executors.newFixedThreadPool(int nThreads)` 创建一个固定大小的线程池（例如，大小为 4）。
        *   创建一个共享的 `Counter` 实例。
        *   循环 10 次，每次创建一个 `Runnable` 任务实例，并使用 `executorService.submit(Runnable task)` 将任务提交给线程池执行。
        *   **重要**：任务提交后，需要关闭线程池。先调用 `executorService.shutdown()`（不再接受新任务，等待已提交任务完成），然后可以调用 `executorService.awaitTermination(long timeout, TimeUnit unit)` 来等待线程池完全终止。
        *   打印最终的 `counter.getCount()` 的值（如果使用了练习 7 的同步 `Counter`，结果应该是 100000）。
    3.  **思考**：使用线程池与手动创建线程相比，代码有何变化？有什么好处？