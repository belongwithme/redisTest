# 进程和线程

## 你如何理解进程和线程

进程是操作系统分配资源的基本单位，而线程是CPU调度的基本单位。

一个进程可以包含多个线程，这些线程共享进程的资源。

我喜欢用餐厅的例子来理解这个概念：
进程就像一家餐厅，拥有自己的场地、设备和资源；

而线程就像餐厅里的员工，如厨师、服务员和收银员，他们共享餐厅的资源，各自负责不同的工作。

## 进程和线程的区别

进程和线程的主要区别体现在以下几个方面:

- 资源占用：进程拥有独立的地址空间和系统资源，而线程共享所属进程的资源。
就像不同餐厅有各自的场地和设备，但同一餐厅的员工共享餐厅的资源。
- 创建和销毁的开销：创建和销毁进程的开销远大于线程。
这就像开设或关闭一家餐厅的成本远高于招聘或解雇一名员工。
- 通信方式：进程间通信相对复杂，需要特殊的IPC机制；而线程间通信简单，可直接共享内存。
这类似于两家餐厅之间需要电话或信使才能沟通，而同一餐厅的员工可以直接交谈。
- 安全性：一个进程崩溃通常不会影响其他进程，但一个线程崩溃可能导致整个进程崩溃。
就像一家餐厅倒闭不会直接影响其他餐厅，但一个厨师的严重失误可能导致整个餐厅的声誉受损。

安全性说完起个引子: 此外，在并发编程中，需要注意线程安全问题。
多个服务员同时使用同一个点餐系统可能导致冲突，就像多线程同时访问共享资源可能导致数据不一致。
为解决这类问题，Java提供了synchronized关键字、Lock接口、原子类等同步机制，以及线程池等高级工具，帮助开发者更安全、高效地进行多线程编程。

## 多线程还是多进程的架构选取

- 浏览器通常采用多进程架构，每个标签页是一个独立进程，这样一个标签页崩溃不会影响其他标签页，提高了稳定性。
- Web服务器如Tomcat则使用多线程处理并发请求，因为线程创建成本低，且请求处理通常需要共享资源如连接池。
- 我在项目中曾经实现过一个文件处理系统，使用多线程并行处理大文件的不同部分，显著提高了处理速度。同时，为了防止一个文件处理失败影响整个系统，我们将不同文件的处理放在不同的进程中执行。

## 一个进程至少包含几个线程？为什么？

标准说法:一个进程至少包含一个线程，这个线程被称为主线程（Main Thread）。
进阶说法:当操作系统创建一个进程时，会自动为该进程创建一个主线程。这个主线程是进程的入口点，负责执行程序的主要逻辑。
主线程的存在是必须的，这里有几个原因:

- 执行入口：进程需要至少一个执行流来运行程序代码，这就是主线程的基本职责。
- 资源管理：主线程负责初始化进程的资源，并在程序结束时释放这些资源。
- 线程创建：只有已存在的线程才能创建新线程，因此主线程是创建其他线程的起点。

例子:
当我开设一家新餐厅（创建进程）时，至少需要一个人（主线程）来负责餐厅的基本运营。这个人可能是老板或经理，负责开门、准备营业、管理餐厅并在结束时关门。随后，根据业务需要，可能会招聘更多员工（创建更多线程）来分担工作，但即使在最简单的情况下，也至少需要这一个人来维持餐厅的基本运作。
(能背就背)当然,还有一些特殊一点的线程:

- 守护线程：除了普通线程外，还有一种特殊的线程叫守护线程（Daemon Thread）。当所有非守护线程结束时，即使守护线程还在运行，进程也会终止。JVM的垃圾回收器就是一个典型的守护线程。
- 特殊情况：在某些操作系统或特定环境中，一个进程可能包含多个"必需"的线程。例如，某些图形界面应用程序可能有一个主线程和一个UI线程。但从最基本的定义来看，一个进程至少需要一个线程。
- 线程模型：不同的操作系统和编程语言可能有不同的线程模型。例如，早期的Java使用绿色线程（Green Threads），这是在用户空间模拟的线程，而不是直接映射到操作系统线程。

## 线程之间共享哪些资源，不共享哪些资源？

共享资源

"同一进程内的线程共享以下资源：

1. 堆内存（Heap） :堆内存是进程中最大的一块内存区域，用于存储动态创建的对象
2. 方法区/元空间 :用于存储类信息、常量、静态变量等
3. 代码段 :存储编译后的代码
4. 全局变量和静态变量 :存储在方法区中
5. 文件描述符等文件资源 :用于文件操作
6. 网络连接等网络资源 :用于网络通信
7. 进程级别的系统资源（如进程ID）

不共享资源

"每个线程拥有自己私有的：

1. 线程栈（Stack） :每个线程的私有栈空间，用于存储局部变量、方法调用栈帧等
2. 程序计数器（PC Register） :存储当前线程执行的指令地址
3. 线程局部存储（ThreadLocal） :用于存储线程私有的数据
4. 线程状态 :每个线程有自己的状态，如运行、等待、阻塞等
5. 异常处理状态 :每个线程有自己的异常处理机制"

顺便说一下:
ThreadLocal是一种特殊的变量，它为每个使用该变量的线程提供一个独立的变量副本。

这在处理线程安全问题时非常有用，比如在Spring框架中用于存储事务信息和请求上下文。

总的来说: 我觉得理解线程间资源共享的边界是并发编程的基础,让我明白如果要设计一个多线程应用时,我们应该尽量减少共享可变状态,对必须共享的资源使用适当的同步机制，并充分利用线程私有资源来提高性能和简化设计。

个人理解版本:
在同一个进程中，线程是为了提高并发性和资源利用率而设计的。因此，它们遵循一个基本原则：共享进程的大部分资源，但拥有各自独立的执行上下文。
具体来说，线程之间 共享 的主要是 进程级别 的资源,包括:
1. 堆内存（Heap）： 这是最重要的共享区域。所有线程都可以访问在堆上创建的对象实例。这也是并发问题（如数据竞争）最常发生的地方。
2. 方法区（或元空间 Metaspace）： 这里存储了类的结构信息、常量池、静态变量等。这些信息是所有线程共用的。
3. 代码段： 加载到内存中的程序代码是所有线程共享执行的。
4. 进程打开的文件描述符和套接字： 如果进程打开了一个文件或网络连接，所有线程都可以使用这些句柄进行读写操作。
5. 全局变量和静态变量： 这些变量本质上存储在方法区或堆中（取决于具体情况），也是线程共享的。

为了保证每个线程能够独立运行和调度，每个线程都拥有一些 私有 的资源，不与其他线程共享。这些主要是线程的 执行上下文：

1. 线程栈（Stack）： 每个线程都有自己独立的栈空间。它用于存储该线程的局部变量、方法参数、以及方法调用的栈帧信息。栈的存在保证了线程内部方法调用的独立性。
2. 程序计数器（PC Register）： 这是一个很小的内存区域，用于记录当前线程将要执行的下一条字节码指令的地址。它是线程切换后能恢复执行的关键。
3. 线程局部存储（ThreadLocal）： 这是一种特殊的机制，允许线程拥有某个变量的独立副本。虽然数据可能最终存在堆上，但访问逻辑上是线程隔离的，常用于在线程内传递上下文信息，避免参数传来传去，或者解决线程安全问题。
4. 线程状态和ID： 每个线程有自己独特的状态（如运行、阻塞、等待等）和标识符。
5. 异常处理栈： 如果线程发生异常，其异常处理信息也是独立的。

理解共享与不共享的边界，对理解并发是很重要的:

正是因为堆内存、静态变量等是共享的，当多个线程同时读写这些共享的可变数据时，才需要同步机制来保证数据的一致性和可见性，避免竞态条件。

而另一方面，线程栈上的局部变量、ThreadLocal 是线程私有的，访问它们不需要加锁，效率更高。

## 线程上下文切换是什么，以及它与进程上下文切换的区别

线程上下文切换是指CPU从一个线程切换到另一个线程时，需要保存当前线程的状态并恢复另一个线程的状态的过程。

这个'状态'，也就是上下文，包括程序计数器、寄存器值和线程栈等信息.

上下文切换的机制我个人认为是:
当操作系统决定进行线程切换时（可能是因为时间片用完、线程阻塞或优先级调度等原因），会触发一个中断，进入内核态。
在内核态中，操作系统会执行以下步骤：

- 保存当前线程的上下文：将CPU寄存器的值、程序计数器等保存到内存中的线程控制块(TCB)。
- 选择下一个要执行的线程：调度器根据调度算法选择下一个线程。
- 恢复被选中线程的上下文：从该线程的TCB中加载上下文到CPU寄存器。
- 切换到用户态：恢复执行被选中的线程。
进程切换除了上述步骤外，还需要切换页表、地址空间等，这就是为什么进程切换比线程切换开销更大的原因。

在Linux系统中，可以通过vmstat命令查看上下文切换的统计信息，通过cs（context switch）列可以看到每秒发生的上下文切换次数。
频繁的上下文切换会导致系统性能下降，这被称为'上下文切换开销'。

进阶: 值得一提的是，不同的线程模型对上下文切换有不同的影响

- 用户级线程模型（如早期Java的绿色线程）：线程切换在用户空间完成，不涉及内核，开销小，但无法利用多核。
- 内核级线程模型（现代操作系统采用）：线程由内核调度，可以利用多核，但切换开销较大。
- 混合线程模型：结合两者优点，如Go语言的goroutine。
此外，现代CPU架构引入了硬件上下文切换支持，如Intel的上下文ID（Context ID）和快速上下文切换（Fast Context Switch Extension），减少了上下文切换的开销。

个人理解版本:

线程上下文切换指的是当 CPU 需要从一个正在执行的线程转而去执行另一个线程时，操作系统所进行的一个必要过程。

这个过程的核心是 保存当前线程的运行状态（即上下文），并加载即将运行线程的状态。这样，当将来切回原来的线程时，它可以从上次中断的地方无缝地继续执行。

这个所谓的'上下文'，主要包含了线程运行所需的核心信息，包括：

1. 程序计数器（PC）： 指示线程下一条要执行的指令地址。
2. 寄存器集合： CPU 中通用寄存器、栈指针等的当前值，它们存储了线程运行时的中间计算结果和状态。
3. 线程栈信息： 虽然栈本身在内存中，但栈顶指针等关键信息需要保存。
这些信息通常保存在操作系统内核为每个线程维护的一个数据结构中，称为线程控制块（TCB）。

线程上下文切换与进程上下文切换的主要区别在于 切换的'重量级'程度不同，这主要体现在**需要保存和恢复的信息范围**上.

线程切换：因为同一进程内的线程 共享 进程的内存地址空间（如堆内存、代码段）以及大部分系统资源（如文件句柄），所以在切换时，只需要 保存和恢复线程私有的那部分状态（主要是上面提到的寄存器、PC、线程栈指针等）。不需要 切换内存地址空间。

进程切换： 进程拥有 独立 的地址空间和资源。因此，进程切换时，除了需要保存和恢复类似线程的CPU状态外，还必须 进行更重量级的操作，包括：

- 切换内存地址空间： 更新页表，让CPU映射到新进程的内存区域。
- 切换内核栈。
- 可能还需要刷新 TLB（Translation Lookaside Buffer） 等缓存。

正是因为进程切换涉及了成本高昂的 内存管理 相关的操作（如地址空间切换、页表更新），所以 进程上下文切换的开销通常远大于线程上下文切换的开销。

线程切换主要开销在于CPU状态的保存和恢复，相对轻量。

无论是哪种切换，上下文切换本身都需要消耗CPU时间，它并不执行任何有用的应用程序代码。因此，过于频繁的上下文切换会显著降低系统的整体性能.

## Java中的线程和操作系统线程是什么关系

Java线程与操作系统线程是一对一的映射关系，这种模型称为'一对一模型'或'内核级线程模型'。

当我们在Java中创建一个线程对象并启动它时，JVM会请求操作系统创建一个原生线程，Java线程的生命周期与这个原生线程直接对应。

这意味着：

- Java线程的调度完全依赖于操作系统的线程调度器
- Java线程会直接映射到操作系统线程，消耗操作系统线程资源
- Java线程的状态变化（如阻塞、唤醒）会转化为操作系统线程的相应状态变化

进阶:
Java线程模型的实现经历了一个演变过程：

- 在早期的JDK 1.2之前，Java使用的是'绿色线程'模型（Green Threads），这是一种用户级线程实现，所有Java线程都由JVM自行调度，而不依赖操作系统。这种模型的优点是线程切换开销小，缺点是无法利用多处理器的并行能力。
- 从JDK 1.3开始，Java转向了'一对一'的线程模型，每个Java线程都映射到一个操作系统线程。这种变化使Java程序能够真正利用多核处理器的并行计算能力，但也增加了线程创建和切换的开销。
- 具体实现上，Java线程是通过JNI（Java Native Interface）调用操作系统的原生线程API来创建和管理线程的

## 线程运行的原理是什么

"线程运行的基本原理可以从操作系统和Java实现两个层面来解释：

### 操作系统层面

1.线程创建：

- 操作系统为新线程分配一个唯一的线程ID
- 创建线程控制块(TCB)，存储线程状态信息
- 分配线程栈空间，用于存储局部变量和调用信息

2.线程调度：
- 操作系统调度器负责决定哪个线程获得CPU时间
- 基于优先级、时间片轮转等算法进行调度
- 线程状态在就绪、运行、阻塞等状态之间转换

3.上下文切换：
- 当一个线程的时间片用完或被阻塞时，CPU保存当前线程的上下文
- 上下文包括程序计数器、寄存器值等执行状态
- CPU加载下一个线程的上下文并恢复执行

### Java层面

1.线程实现：

- JVM将Java线程映射到操作系统原生线程
- 通过JNI调用操作系统的线程API创建和管理线程
- 每个Java线程都有自己的Java栈、程序计数器和本地方法栈

2.线程状态管理：

- Java定义了六种线程状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING和TERMINATED
- JVM负责维护线程状态的转换
- 通过synchronized、wait/notify等机制实现线程同步"

个人理解版本:
线程运行的原理可以从两个层面来看：操作系统层面 和 Java (JVM) 层面。
操作系统提供了线程运行的基础设施，而 Java 在此之上进行了封装和管理。
首先，在 操作系统层面，线程是 CPU 调度的基本单位。
它的运行主要有三步:

1. 创建线程:请求创建一个线程时，操作系统会为其分配必要的资源.(后续记住就说,记不住算了)最核心的是一个 线程控制块（TCB），用来记录线程的 ID、状态、优先级、寄存器值等信息，以及一个独立的 线程栈，用于存储该线程的局部变量和函数调用信息。
2. 调度： 操作系统有一个 调度器，它根据特定的调度算法（如时间片轮转、优先级抢占等）来决定当前哪个处于 '就绪' 状态的线程可以获得 CPU 的执行权。
3. 执行与切换： 当一个线程获得 CPU 后，它就开始执行指令。CPU 通过 上下文切换 机制在不同的线程之间切换。
其次，在 Java (JVM) 层面，我们平时使用的 java.lang.Thread 是对操作系统线程的一种 抽象和封装。
它的运行通常有四步:

    1. 映射:JVM 会将 Java 线程一对一地映射到底层的操作系统原生线程。(不需要记)我们调用 thread.start() 时，JVM 最终会通过 JNI (Java Native Interface) 去调用操作系统的 API 来创建一个真正的内核线程。"
    2. Java 内存模型与线程资源: Java 线程除了共享进程的堆内存和方法区外，还拥有自己独立的 Java 虚拟机栈（用于 Java 方法调用）、本地方法栈（用于 Native 方法调用）和 程序计数器。
    3. Java 线程状态: Java 定义了一套自己的线程状态,JVM 负责维护这些状态，并在 Java 层面管理线程的生命周期。
    4. 同步机制: Java 提供了丰富的 同步机制（如 synchronized 关键字、Lock 接口、wait/notify/notifyAll 方法、volatile 关键字等）来协调多个线程对共享资源的访问，这是 Java 并发编程的核心。

## 如果一个Java应用出现了内存泄漏，可能与线程有什么关系？如何排查？

Java应用中的内存泄漏与线程的关系通常体现在以下几个方面：

1.线程池未正确关闭：

- 线程池中的线程持有对象引用但未被释放
- 应用停止但线程池未关闭，导致线程及其引用的对象无法被回收

2.ThreadLocal使用不当：

- ThreadLocal变量未及时清理
- 特别是在线程池环境下，线程复用导致ThreadLocal中的对象累积

3.线程持有的静态资源：

- 线程中使用静态集合存储数据但未清理
- 长时间运行的线程不断向静态集合添加数据

4.未终止的后台线程：

- 创建的后台线程未设置为守护线程
- 线程内有无限循环但应用未提供停止机制

5.线程同步导致的死锁或资源阻塞：

- 线程间死锁导致任务无法完成，相关资源无法释放
- 线程等待某个永远不会到来的信号，导致资源无法释放

排查:

a. 堆转储分析：

- 使用jmap生成堆转储文件：jmap -dump:format=b,file=heap.bin <pid>
- 使用MAT(Memory Analyzer Tool)或VisualVM分析堆转储文件
- 查找大对象、重复对象和引用链

b. 线程转储分析：

- 使用jstack生成线程转储：`jstack <pid> > thread_dump.txt`
- 分析线程状态，查找BLOCKED或长时间WAITING的线程
- 检查是否存在死锁情况

c. 内存监控：

- 使用JConsole或VisualVM实时监控内存使用趋势
- 观察内存使用是否持续增长而不释放

d. 代码审查：

- 检查ThreadLocal使用是否有remove()调用
- 审查线程池配置和关闭逻辑
- 检查静态集合的使用和清理

个人理解版本:

Java 应用出现内存泄漏，确实可能与线程有关系.

虽然线程本身作为对象也会占用内存，但通常我们说的内存泄漏是指:

由线程（特别是生命周期管理不当的线程）持有或间接持有的某些对象，在逻辑上已经不再需要了，但因为线程的引用链仍然存在，导致垃圾回收器（GC）无法回收这些对象，从而造成内存持续被占用，最终可能导致 OutOfMemoryError。

我能想到的有几种场景和线程相关:

a. ThreadLocal 使用不当（最常见）:
这是非常典型的一种场景。ThreadLocal 为每个线程提供了变量的副本。

但 ThreadLocalMap（Thread 对象的内部成员）的 Key 是 ThreadLocal 对象的弱引用，而 Value 是我们存入的对象（强引用）。

如果 ThreadLocal 对象本身被回收了（比如设置为 null），但线程还在运行（尤其是在线程池中被复用时），那么 ThreadLocalMap 中对应的 Entry 的 Key 变为 null，但 Value（我们存入的对象）仍然被强引用着，无法被 GC 回收，直到线程结束。

如果线程长时间不结束（线程池核心线程），这个 Value 对象就泄漏了。最佳实践是在使用完 ThreadLocal 后，显式调用 remove() 方法清理。

b. 长生命周期线程持有短生命周期对象的引用：

如果一个线程运行时间很长（比如后台任务线程、线程池中的核心线程），并且它直接或间接地持有了一些它在某个阶段临时使用、但后续不再需要的对象的引用（比如在一个大的集合中添加了对象但忘记移除，或者持有某个任务上下文对象的引用），那么只要这个长生命周期的线程还在运行，这些不再需要的对象就无法被回收，造成泄漏。

c. 静态变量持有线程相关或大量数据：

如果一个 static 字段（生命周期与 ClassLoader 一致，通常很长）持有了某个与特定线程相关的对象引用，或者是一个集合，不断被不同线程往里添加数据而没有清理机制，也可能导致内存泄漏。虽然不是线程直接持有，但线程的操作导致了静态集合的膨胀。

d. 资源未关闭：

线程执行任务时打开了外部资源（如文件句柄、数据库连接、网络连接），如果在 finally 块或等效逻辑中没有确保这些资源被正确关闭，不仅可能导致资源泄漏，相关的对象（如 Connection 对象、Stream 对象）也可能因为被线程或其引用的对象持有而无法及时回收，间接导致内存占用增加。
