面几个练习题，从易到难，帮助巩固 `start()`, `sleep()`, `join()`, `interrupt()` 等核心操作的用法。

---

## 练习 1：创建和启动线程

*   **目标**：练习使用两种主要方式创建和启动线程，观察并发执行的基本现象。
*   **要求**：
    1.  创建一个类 `MyThreadTask` 继承自 `Thread`，重写 `run()` 方法，在方法中打印 5 次当前线程的名字和循环次数（例如："Thread-MyThreadTask: 0", "Thread-MyThreadTask: 1", ...）。
    2.  创建一个类 `MyRunnableTask` 实现 `Runnable` 接口，实现 `run()` 方法，在方法中打印 5 次当前线程的名字和循环次数（例如："Thread-MyRunnableTask: 0", ...）。
    3.  在 `main` 方法中：
        *   创建并启动 2 个 `MyThreadTask` 线程实例。
        *   创建 2 个 `MyRunnableTask` 任务实例，然后用它们分别创建并启动 2 个 `Thread` 实例。
        *   给每个线程设置一个有意义的名字。
        *   观察控制台的输出，注意不同线程的打印语句是如何交错执行的。

**答案:**
```java
import java.util.concurrent.TimeUnit; // 用于简化 sleep

// 方式一：继承 Thread 类
class MyThreadTask extends Thread {
    public MyThreadTask(String name) {
        super(name); // 调用父类构造函数设置线程名称
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("Thread [" + Thread.currentThread().getName() + "]: count " + i);
            // 短暂休眠，让其他线程有机会执行，更容易看到交错效果
            try {
                TimeUnit.MILLISECONDS.sleep(10);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println("Thread [" + Thread.currentThread().getName() + "] finished.");
    }
}

// 方式二：实现 Runnable 接口
class MyRunnableTask implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("Runnable Task in Thread [" + Thread.currentThread().getName() + "]: count " + i);
            try {
                TimeUnit.MILLISECONDS.sleep(10);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
         System.out.println("Runnable Task in Thread [" + Thread.currentThread().getName() + "] finished.");
    }
}

public class Exercise1 {
    public static void main(String[] args) {
        System.out.println("Main thread started.");

        // 创建并启动 MyThreadTask 实例
        MyThreadTask threadTask1 = new MyThreadTask("MyThread-1");
        MyThreadTask threadTask2 = new MyThreadTask("MyThread-2");
        threadTask1.start();
        threadTask2.start();

        // 创建 MyRunnableTask 实例
        MyRunnableTask runnableTask1 = new MyRunnableTask();
        MyRunnableTask runnableTask2 = new MyRunnableTask();

        // 使用 MyRunnableTask 创建并启动 Thread 实例
        Thread runnableThread1 = new Thread(runnableTask1, "MyRunnableThread-1");
        Thread runnableThread2 = new Thread(runnableTask2, "MyRunnableThread-2");
        runnableThread1.start();
        runnableThread2.start();

        System.out.println("Main thread finished starting other threads.");
        // main 线程会继续执行，可能比子线程先结束
    }
}
```

---

## 练习 2：使用 `Thread.sleep()`

*   **目标**：理解 `sleep()` 的作用，即让当前线程暂停执行一段时间。
*   **要求**：
    1.  修改练习 1 中的 `run()` 方法（两个类都需要修改）。
    2.  在每次打印循环次数后，让当前线程调用 `Thread.sleep()` 随机休眠一段时间（例如 100 到 500 毫秒之间）。可以使用 `java.util.Random` 类生成随机数。
    3.  注意处理 `InterruptedException`（可以简单打印异常信息或重新设置中断状态）。
    4.  再次运行 `main` 方法，观察线程的执行顺序与之前有何不同，执行的总时间是否变长了。

**答案:**
```java
import java.util.Random;
import java.util.concurrent.TimeUnit;

// 修改 MyThreadTask
class MyThreadTaskWithSleep extends Thread {
    private Random random = new Random();

    public MyThreadTaskWithSleep(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("Thread [" + getName() + "]: count " + i);
            try {
                // 随机休眠 100 到 500 毫秒
                int sleepTime = 100 + random.nextInt(401); // random.nextInt(401) -> [0, 400]
                System.out.println("Thread [" + getName() + "] sleeping for " + sleepTime + " ms...");
                TimeUnit.MILLISECONDS.sleep(sleepTime);
            } catch (InterruptedException e) {
                System.out.println("Thread [" + getName() + "] was interrupted during sleep.");
                Thread.currentThread().interrupt(); // 重新设置中断状态
                // 决定是否退出循环
                 break;
            }
        }
         System.out.println("Thread [" + getName() + "] finished.");
    }
}

// 修改 MyRunnableTask
class MyRunnableTaskWithSleep implements Runnable {
     private Random random = new Random();

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        for (int i = 0; i < 5; i++) {
             System.out.println("Runnable Task in Thread [" + threadName + "]: count " + i);
            try {
                int sleepTime = 100 + random.nextInt(401);
                System.out.println("Runnable Task in Thread [" + threadName + "] sleeping for " + sleepTime + " ms...");
                TimeUnit.MILLISECONDS.sleep(sleepTime);
            } catch (InterruptedException e) {
                 System.out.println("Runnable Task in Thread [" + threadName + "] was interrupted during sleep.");
                Thread.currentThread().interrupt();
                break;
            }
        }
        System.out.println("Runnable Task in Thread [" + threadName + "] finished.");
    }
}


public class Exercise2 {
    public static void main(String[] args) {
         System.out.println("Main thread started.");

        MyThreadTaskWithSleep threadTask1 = new MyThreadTaskWithSleep("MyThread-Sleep-1");
        MyThreadTaskWithSleep threadTask2 = new MyThreadTaskWithSleep("MyThread-Sleep-2");
        threadTask1.start();
        threadTask2.start();

        MyRunnableTaskWithSleep runnableTask1 = new MyRunnableTaskWithSleep();
        MyRunnableTaskWithSleep runnableTask2 = new MyRunnableTaskWithSleep();

        Thread runnableThread1 = new Thread(runnableTask1, "MyRunnableThread-Sleep-1");
        Thread runnableThread2 = new Thread(runnableTask2, "MyRunnableThread-Sleep-2");
        runnableThread1.start();
        runnableThread2.start();

        System.out.println("Main thread finished starting other threads.");
    }
}
```

---

## 练习 3：使用 `thread.join()`

*   **目标**：学习如何让一个线程等待另一个线程执行完成。
*   **要求**：
    1.  创建一个 `WorkerThread` 类（可以是继承 `Thread` 或实现 `Runnable`），其 `run()` 方法模拟一个耗时任务（例如，循环计算或者 `sleep` 几秒钟），并在任务开始和结束时打印消息。
    2.  在 `main` 方法中：
        *   创建并启动 3 个 `WorkerThread` 实例。
        *   在启动所有 worker 线程后，`main` 线程需要等待**所有**这 3 个 worker 线程都执行完毕。使用 `join()` 方法来实现这一点。
        *   当所有 worker 线程都结束后，`main` 线程打印一条 "所有工作线程已完成！" 的消息。

**答案:**
```java
import java.util.concurrent.TimeUnit;

class WorkerThread implements Runnable {
    private String name;
    private long workDurationMillis;

    public WorkerThread(String name, long workDurationMillis) {
        this.name = name;
        this.workDurationMillis = workDurationMillis;
    }

    @Override
    public void run() {
        System.out.println("Worker [" + name + "] started.");
        try {
            System.out.println("Worker [" + name + "] working for " + workDurationMillis + " ms...");
            TimeUnit.MILLISECONDS.sleep(workDurationMillis);
        } catch (InterruptedException e) {
             System.out.println("Worker [" + name + "] was interrupted.");
             Thread.currentThread().interrupt();
        }
        System.out.println("Worker [" + name + "] finished.");
    }
}

public class Exercise3 {
    public static void main(String[] args) {
        System.out.println("Main thread started.");

        Thread worker1 = new Thread(new WorkerThread("Worker-1", 2000)); // 工作 2 秒
        Thread worker2 = new Thread(new WorkerThread("Worker-2", 3000)); // 工作 3 秒
        Thread worker3 = new Thread(new WorkerThread("Worker-3", 1500)); // 工作 1.5 秒

        worker1.start();
        worker2.start();
        worker3.start();

        System.out.println("Main thread waiting for workers to finish...");

        try {
            // 等待每个 worker 线程结束
            worker1.join();
            System.out.println("Worker-1 finished, joining Worker-2...");
            worker2.join();
             System.out.println("Worker-2 finished, joining Worker-3...");
            worker3.join();
             System.out.println("Worker-3 finished.");
        } catch (InterruptedException e) {
            System.out.println("Main thread was interrupted while waiting.");
            Thread.currentThread().interrupt();
        }

        System.out.println("所有工作线程已完成！ Main thread finished.");
    }
}
```

---

## 练习 4：处理线程中断 `interrupt()`

*   **目标**：练习如何优雅地响应中断请求。
*   **要求**：
    1.  创建一个 `LongRunningTask` 类实现 `Runnable`。
    2.  在其 `run()` 方法中，实现一个长时间运行的循环（例如，循环很多次或者使用 `while(true)`）。
    3.  在循环体内部：
        *   **方式一（检查中断标志）**：在循环条件或循环体内，使用 `Thread.currentThread().isInterrupted()` 检查中断状态。如果发现被中断，打印一条消息并**退出循环**（结束 `run` 方法）。在循环中可以加入短暂的 `sleep`（例如 100 毫秒）来模拟工作并降低 CPU 占用，但主要依靠 `isInterrupted()` 来退出。
        *   **方式二（响应 `InterruptedException`）**：让线程在循环中调用 `Thread.sleep()`（例如 `sleep(500)`）。在 `catch (InterruptedException e)` 块中，打印被中断的消息，并**退出循环**。**记住**，捕获 `InterruptedException` 后需要**重新设置中断状态** (`Thread.currentThread().interrupt()`) 是一个好习惯，除非你确定当前就是处理中断的最终层级。
    4.  在 `main` 方法中：
        *   创建并启动一个运行 `LongRunningTask` 的线程。
        *   让 `main` 线程 `sleep` 一小段时间（例如 3 秒）。
        *   调用任务线程的 `interrupt()` 方法来请求中断。
        *   （可选）调用任务线程的 `join()` 方法等待它真正结束。
        *   观察任务线程是否按预期停止了执行。

**答案:**
```java
import java.util.concurrent.TimeUnit;

// 方式一：检查中断标志
class LongRunningTaskCheckInterrupt implements Runnable {
    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        System.out.println("Task [" + threadName + "] started (checking interrupt flag).");
        long counter = 0;
        // 使用 isInterrupted() 检查，它不清除中断状态
        while (!Thread.currentThread().isInterrupted()) {
            counter++;
            if (counter % 100000000 == 0) { // 打印进度，避免刷屏
                 System.out.println("Task [" + threadName + "] still running (checked flag)... counter=" + counter);
            }
            // 可以加入短暂休眠，模拟工作并降低CPU占用，但中断主要靠标志检查
            // try {
            //     TimeUnit.MILLISECONDS.sleep(1);
            // } catch (InterruptedException e) {
            //     // 如果在 sleep 中被中断，也会抛异常，也需要处理
            //     System.out.println("Task [" + threadName + "] interrupted during optional sleep!");
            //     Thread.currentThread().interrupt(); // 重新设置状态
            //     break; // 退出循环
            // }
        }
        // 循环结束，说明检测到了中断标志
        System.out.println("Task [" + threadName + "] detected interrupt flag, stopping. Final counter=" + counter);
        System.out.println("Task [" + threadName + "] finished.");
    }
}

// 方式二：响应 InterruptedException
class LongRunningTaskRespondInterrupt implements Runnable {
    @Override
    public void run() {
         String threadName = Thread.currentThread().getName();
         System.out.println("Task [" + threadName + "] started (responding to InterruptedException).");
         long counter = 0;
         try {
             while (true) { // 依赖 sleep 抛出异常来中断
                 counter++;
                 if (counter % 5 == 0) { // 每 5 次打印一次
                    System.out.println("Task [" + threadName + "] still running (sleep)... counter=" + counter);
                 }
                 // sleep 会检查中断状态，如果被中断则抛出 InterruptedException
                 TimeUnit.MILLISECONDS.sleep(500);
             }
         } catch (InterruptedException e) {
             // 捕获中断异常
             System.out.println("Task [" + threadName + "] caught InterruptedException, stopping. Final counter=" + counter);
             // 重要：重新设置中断状态，通知上层调用者发生过中断
             Thread.currentThread().interrupt();
         }
         System.out.println("Task [" + threadName + "] finished.");
    }
}


public class Exercise4 {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("Main thread started.");

        // 测试方式一
        System.out.println("\n--- Testing LongRunningTaskCheckInterrupt ---");
        Thread taskThread1 = new Thread(new LongRunningTaskCheckInterrupt(), "CheckInterruptTask");
        taskThread1.start();
        TimeUnit.SECONDS.sleep(2); // 让任务运行 2 秒
        System.out.println("Main thread interrupting CheckInterruptTask...");
        taskThread1.interrupt(); // 发送中断请求
        taskThread1.join(); // 等待任务线程结束
        System.out.println("CheckInterruptTask thread joined.");
        System.out.println("CheckInterruptTask final interrupted status: " + taskThread1.isInterrupted());


         // 测试方式二
        System.out.println("\n--- Testing LongRunningTaskRespondInterrupt ---");
        Thread taskThread2 = new Thread(new LongRunningTaskRespondInterrupt(), "RespondInterruptTask");
        taskThread2.start();
        TimeUnit.SECONDS.sleep(3); // 让任务运行 3 秒
        System.out.println("Main thread interrupting RespondInterruptTask...");
        taskThread2.interrupt(); // 发送中断请求
        taskThread2.join(); // 等待任务线程结束
        System.out.println("RespondInterruptTask thread joined.");
        // 因为在 catch 块中调用了 Thread.currentThread().interrupt()，所以最终状态应该是 true
        System.out.println("RespondInterruptTask final interrupted status: " + taskThread2.isInterrupted());


        System.out.println("\nMain thread finished.");
    }
}
```

---

## 练习 5：综合应用（可选挑战）

*   **目标**：结合使用多种线程操作解决一个稍微复杂点的问题。
*   **要求**：
    1.  模拟一个简单的下载任务。
    2.  创建一个 `Downloader` 线程，它模拟下载过程：循环 10 次，每次打印 "正在下载... 第 x%"，并在每次打印后 `sleep(300)` 毫秒。在循环内部检查中断状态，如果被中断则打印 "下载被取消！" 并退出。下载完成后打印 "下载完成！"。
    3.  在 `main` 方法中：
        *   启动 `Downloader` 线程。
        *   启动另一个 `TimeoutWatcher` 线程（可以使用 Lambda 表达式创建）。这个线程 `sleep` 2 秒钟。如果在 2 秒内 `Downloader` 线程还没有结束 (`isAlive()` 可以判断)，`TimeoutWatcher` 就调用 `downloader.interrupt()` 来取消下载。
        *   `main` 线程使用 `downloader.join()` 等待下载线程结束（无论是因为完成还是被取消）。
        *   最后根据 `downloader` 线程是否还存活（或者通过其他标志）来判断下载是成功完成还是被取消了。

**答案:**
```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean; // 用于线程间通信的标志

class Downloader implements Runnable {
    // 使用 AtomicBoolean 作为完成标志，是线程安全的
    private final AtomicBoolean completedSuccessfully = new AtomicBoolean(false);
    private final AtomicBoolean cancelled = new AtomicBoolean(false);

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        System.out.println("[" + threadName + "] Download started.");
        try {
            for (int i = 0; i <= 100; i += 10) {
                // 检查中断状态
                if (Thread.currentThread().isInterrupted()) {
                    // 如果在循环开始或中间被中断
                    cancelled.set(true);
                    System.out.println("\n[" + threadName + "] Download interrupted (checked flag) at " + i + "%!");
                    // 清理操作（如果需要）
                    return; // 退出 run 方法
                }

                System.out.print("[" + threadName + "] Downloading... " + i + "% ");
                // 模拟下载耗时
                TimeUnit.MILLISECONDS.sleep(300);
            }
            // 循环正常完成
            System.out.println("\n[" + threadName + "] Download completed successfully!");
            completedSuccessfully.set(true);

        } catch (InterruptedException e) {
            // 如果在 sleep 时被中断
             cancelled.set(true);
             System.out.println("\n[" + threadName + "] Download interrupted during sleep!");
             // 不需要再次调用 interrupt()，因为上游 TimeoutWatcher 就是中断源
             // Thread.currentThread().interrupt(); // 如果希望保持中断状态，可以加这行
        } finally {
            System.out.println("[" + threadName + "] Exiting run method.");
        }
    }

    public boolean isCompletedSuccessfully() {
        return completedSuccessfully.get();
    }

     public boolean isCancelled() {
        return cancelled.get();
    }
}

public class Exercise5 {
    public static void main(String[] args) {
        System.out.println("Main thread started.");

        Downloader downloaderTask = new Downloader();
        Thread downloaderThread = new Thread(downloaderTask, "Downloader");

        // 创建超时监控线程
        Thread timeoutWatcherThread = new Thread(() -> {
            String watcherName = Thread.currentThread().getName();
            System.out.println("[" + watcherName + "] Started, will interrupt downloader after 2 seconds if still running.");
            try {
                TimeUnit.SECONDS.sleep(2); // 等待 2 秒

                // 检查下载线程是否还在运行
                if (downloaderThread.isAlive()) {
                    System.out.println("[" + watcherName + "] Downloader is still running after 2 seconds. Interrupting...");
                    downloaderThread.interrupt(); // 发送中断请求
                } else {
                     System.out.println("[" + watcherName + "] Downloader finished within 2 seconds.");
                }
            } catch (InterruptedException e) {
                 System.out.println("[" + watcherName + "] was interrupted.");
                 Thread.currentThread().interrupt();
            }
             System.out.println("[" + watcherName + "] Finished.");
        }, "TimeoutWatcher");

        // 启动下载线程和监控线程
        downloaderThread.start();
        timeoutWatcherThread.start();

        // Main 线程等待下载线程结束（无论完成或被取消）
        try {
            System.out.println("[Main] Waiting for downloader thread to join...");
            downloaderThread.join();
            System.out.println("[Main] Downloader thread joined.");
        } catch (InterruptedException e) {
             System.out.println("[Main] Interrupted while waiting for downloader.");
             Thread.currentThread().interrupt();
        }

        // 判断最终结果
        if (downloaderTask.isCompletedSuccessfully()) {
            System.out.println("[Main] Final Status: Download Completed Successfully!");
        } else if (downloaderTask.isCancelled()) {
             System.out.println("[Main] Final Status: Download Was Cancelled/Interrupted!");
        } else {
            // 可能的情况：线程异常退出等（本例中不太可能）
             System.out.println("[Main] Final Status: Download did not complete or cancel as expected.");
        }

         System.out.println("Main thread finished.");
    }
}
```

---

## 练习 6：理解竞态条件 (Race Condition)

*   **目标**：亲身体验多线程访问共享资源时可能出现的问题，理解为何需要同步。
*   **要求**：
    1.  创建一个类 `Counter`，它有一个实例变量 `private int count = 0;` 和一个 `increment()` 方法，该方法执行 `count++`。再添加一个 `getCount()` 方法返回 `count` 的值。
    2.  创建一个 `Runnable` 任务，在其 `run()` 方法中，循环调用 `Counter` 对象的 `increment()` 方法 10000 次。
    3.  在 `main` 方法中：
        *   创建一个共享的 `Counter` 实例。
        *   创建并启动 10 个线程，每个线程都执行上述的 `Runnable` 任务（操作同一个 `Counter` 实例）。
        *   使用 `join()` 等待所有这 10 个线程都执行完毕。
        *   打印最终 `counter.getCount()` 的值。
    4.  **思考与观察**：
        *   预期的最终 `count` 值应该是多少？ (10 * 10000 = 100000)
        *   多次运行程序，观察实际打印的最终 `count` 值是多少？它是否总是等于预期值？为什么会出现这种情况？（提示：`count++` 不是原子操作）

答案:
```java
class Counter {
    private int count = 0;
    public void increment() { count++; }
    public int getCount() { return count; }
}

public class demo {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        // Runnable 任务，确保循环能正确执行 10000 次
        Runnable runnable = () -> { // 使用 Lambda 表达式简化
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
        };
        // 或者你的原始 Runnable 修改后：
        /*
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                // 使用 for 循环确保次数正确
                for (int n = 0; n < 10000; n++) {
                    counter.increment();
                }
            }
        };
        */


        int numThreads = 10;
        Thread[] threads = new Thread[numThreads]; // 创建一个数组来存储线程引用

        // 第一个循环：启动所有线程
        System.out.println("Starting all threads...");
        for (int i = 0; i < numThreads; i++) {
            threads[i] = new Thread(runnable);
            threads[i].start(); // 仅仅启动，不等待
        }

        // 第二个循环：等待所有线程结束
        System.out.println("Waiting for all threads to finish...");
        for (int i = 0; i < numThreads; i++) {
            threads[i].join(); // 在所有线程都启动后再等待它们
        }

        System.out.println("All threads finished.");
        System.out.println("Expected final count: " + (numThreads * 10000));
        System.out.println("Actual final count:   " + counter.getCount()); // 现在应该能看到小于预期值的情况了
    }
}
```

思考与观察解答：
预期值：100000 (10 个线程，每个线程增加 10000 次)。
实际值：多次运行会发现，实际打印的 count 值几乎总是小于 100000，并且每次运行的结果可能都不同。
原因：count++ 这个操作看起来简单，但它在字节码层面（甚至在 CPU 指令层面）通常包含三个步骤：
读取 count 的当前值到工作内存（或寄存器）。
将读取到的值加 1。
将计算后的新值写回 count 变量（写回主内存）。
由于这三个步骤不是原子的，多个线程并发执行 increment() 时，可能会发生以下情况（竞态条件）：
线程 A 读取 count (假设为 5)。
线程 B 也读取 count (也读取到 5)。
线程 A 计算 5 + 1 = 6，并将 6 写回 count。
线程 B 计算 5 + 1 = 6，并将 6 写回 count。
虽然两个线程都执行了 increment()，但 count 最终只增加了 1（变成了 6），而不是期望的增加 2（变成 7）。这种读写冲突导致了最终结果丢失了一部分增量。
---

## 练习 7：使用 synchronized 解决竞态条件

*   **目标**：学习使用 `synchronized` 关键字保护共享资源，解决练习 6 中出现的问题。
*   **要求**：
    1.  基于练习 6 的代码。
    2.  修改 `Counter` 类的 `increment()` 方法和 `getCount()` 方法（或者只修改 `increment`，取决于你认为哪里需要保护），使用 `synchronized` 关键字来保证对 `count` 变量访问的原子性和可见性。你可以选择同步整个方法，或者使用 `synchronized(this)` 代码块。
    3.  再次运行 `main` 方法多次。
    4.  **观察**：现在最终的 `count` 值是否总是等于预期值 100000？ `synchronized` 是如何解决问题的？


答案:
```java
// 修改 Counter 类
class SynchronizedCounter {
    private int count = 0;

    // 使用 synchronized 修饰实例方法，锁是 this 对象
    public synchronized void increment() {
        count++; // 现在这个操作是原子的，且对其他线程可见
    }

    // 读取操作最好也加上 synchronized，保证可见性
    // (虽然在这个特定例子里，由于 join() 的 happens-before 保证，
    //  即使 getCount() 不加 synchronized 可能也能看到正确结果，
    //  但加锁是更严谨的做法)
    public synchronized int getCount() {
        return count;
    }

    // 或者使用同步代码块 (效果相同)
    /*
    private final Object lock = new Object(); // 可以创建一个专门的锁对象
    public void increment() {
        synchronized (this) { // 或 synchronized(lock)
            count++;
        }
    }
    public int getCount() {
        synchronized (this) { // 或 synchronized(lock)
            return count;
        }
    }
    */
}
```
现在多次运行程序，最终的 count 值总是等于 100000。
synchronized 如何解决问题：
互斥性/原子性：synchronized 关键字保证了 increment() 方法（或同步块）在同一时刻只能被一个线程执行。当一个线程进入 increment() 时，它会获取 sharedCounter 对象（this）的锁，其他线程如果想进入 increment()（或同一个对象的其他 synchronized 方法/块），就必须等待该线程释放锁。这使得 count++ 的“读-改-写”三个步骤作为一个不可分割的原子单元执行，不会被其他线程干扰。
可见性：当一个线程退出 synchronized 方法/块（释放锁）时，JMM 会保证它对共享变量（count）的修改刷新到主内存。当另一个线程进入同一个 synchronized 方法/块（获取锁）时，JMM 会保证它从主内存读取最新的共享变量值。这确保了一个线程对 count 的修改对后续获取锁的线程是可见的。
---

## 练习 8：使用 volatile 实现状态标志

*   **目标**：理解 `volatile` 在保证可见性方面的作用，适用于简单的状态控制。
*   **要求**：
    1.  创建一个 `Worker` 类实现 `Runnable`。
    2.  `Worker` 类有一个 `private volatile boolean running = true;` 实例变量。
    3.  `run()` 方法包含一个 `while(running)` 循环，在循环中打印 "Worker is running..." 并短暂 `sleep`（例如 200 毫秒）。
    4.  `Worker` 类提供一个 `public void stopWorker()` 方法，该方法将 `running` 设置为 `false`。
    5.  在 `main` 方法中：
        *   创建 `Worker` 实例。
        *   创建并启动一个线程来运行 `Worker` 任务。
        *   让 `main` 线程 `sleep` 1 秒钟。
        *   调用 `worker.stopWorker()` 方法。
        *   观察 worker 线程是否能够正常停止。（提示：如果没有 `volatile`，可能会因为可见性问题导致 worker 线程无法看到 `running` 变为 `false` 而一直循环下去）。

答案:
```java
import java.util.concurrent.TimeUnit;

class VolatileWorker implements Runnable {
    // 使用 volatile 保证可见性
    private volatile boolean running = true;

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        System.out.println("[" + threadName + "] Worker started.");
        while (running) { // 读取 volatile 变量
            System.out.println("[" + threadName + "] Worker is running...");
            try {
                // 短暂休眠，模拟工作，也让主线程有机会执行 stopWorker
                TimeUnit.MILLISECONDS.sleep(200);
            } catch (InterruptedException e) {
                // 如果在 sleep 时被中断，也应该停止
                System.out.println("[" + threadName + "] Worker interrupted during sleep, stopping.");
                // 不需要设置 running = false，因为中断也意味着要停止
                Thread.currentThread().interrupt(); // 保持中断状态
                break; // 退出循环
            }
        }
        System.out.println("[" + threadName + "] Worker stopped.");
    }

    public void stopWorker() {
        System.out.println("[Main thread] Requesting worker to stop...");
        this.running = false; // 写入 volatile 变量
    }
}

public class Exercise8 {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("Main thread started.");

        VolatileWorker workerTask = new VolatileWorker();
        Thread workerThread = new Thread(workerTask, "VolatileWorkerThread");
        workerThread.start();

        // 让 worker 线程运行 1 秒
        TimeUnit.SECONDS.sleep(1);

        // 从主线程请求停止 worker 线程(注意这个方法是在主线程里面被调用的!)
        workerTask.stopWorker();

        // (可选) 等待 worker 线程真正结束
        workerThread.join();
        System.out.println("Worker thread joined.");

        System.out.println("Main thread finished.");
    }
}
```
运行程序，会看到 worker 线程打印 "Worker is running..." 几次后，在 main 线程调用 stopWorker() 将 running 设置为 false 后，worker 线程能够检测到 running 值的变化，退出 while 循环，并打印 "Worker stopped."。
volatile 的作用：
当 main 线程执行 workerTask.stopWorker()，写入 running = false; 时，volatile 关键字保证了这个新值 (false) 会被立即强制写回主内存。
当 workerThread 在下一次循环判断 while(running) 时，volatile 关键字保证了它会强制从主内存中读取 running 的最新值，而不是使用自己工作内存中可能存在的旧值 (true)。
这样就确保了 main 线程对 running 标志的修改能够及时被 workerThread 看到，从而实现了线程的正常停止。
如果没有 volatile，workerThread 可能会因为 CPU 缓存等原因一直读取到旧的 running 值 (true)，导致无法停止（活性问题）。
---


## 练习 9：使用 wait() / notify() 实现生产者-消费者

*   **目标**：学习使用 `Object` 的 `wait()`, `notify()` (或 `notifyAll()`) 方法进行线程间通信，实现经典的生产者-消费者模式。
*   **要求**：
    1.  创建一个缓冲区类 `Buffer`（例如，使用 `LinkedList` 或 `ArrayDeque` 作为内部存储），它有固定的大小（比如 5）。
    2.  `Buffer` 类需要两个方法：
        *   `produce(int item)`: 向缓冲区添加物品。如果缓冲区已满，生产者线程需要调用 `wait()` 等待。添加成功后，需要调用 `notifyAll()` 唤醒可能在等待的消费者线程。
        *   `consume()`: 从缓冲区取出物品。如果缓冲区为空，消费者线程需要调用 `wait()` 等待。取出成功后，需要调用 `notifyAll()` 唤醒可能在等待的生产者线程。
    3.  **重要**：`produce` 和 `consume` 方法都需要使用 `synchronized` 关键字（或同步块）来保护对缓冲区的访问以及 `wait/notify` 的调用（因为 `wait/notify` 必须在同步块/方法内调用）。 `wait()` 的调用通常放在 `while` 循环中检查条件，以防止虚假唤醒 (spurious wakeup)。
    4.  创建生产者 `Producer` 线程（实现 `Runnable`），循环生产物品（例如从 0 开始递增的整数）并放入 `Buffer`。
    5.  创建消费者 `Consumer` 线程（实现 `Runnable`），循环从 `Buffer` 取出物品并打印。
    6.  在 `main` 方法中：
        *   创建共享的 `Buffer` 实例。
        *   启动一个或多个生产者线程。
        *   启动一个或多个消费者线程。
        *   观察生产者和消费者是否能正确地交替工作，缓冲区是否不会溢出或空等。
答案:
```java
public class exercise9 {
    public static void main(String[] args) {
        // int n = 0; // 'n' 在这里声明并在匿名内部类中使用，会导致问题

        Buffer buffer = new Buffer(5); // *** 指定容量 ***

        // --- 生产者任务 ---
        Runnable ProRunnable = new Runnable() {
            private int itemToProduce = 0; // 每个生产者维护自己的生产序列

            @Override
            public void run() {
                try { // *** 最好加上 try-catch 处理中断 ***
                    while (true) { // 或者有明确的生产数量
                        buffer.produce(itemToProduce);
                        System.out.println("Producer [" + Thread.currentThread().getName() + "] Produced: " + itemToProduce);
                        itemToProduce++; // 生产下一个
                        // 模拟生产耗时
                        Thread.sleep((long)(Math.random() * 500)); // *** 加入随机休眠方便观察 ***
                    }
                } catch (InterruptedException e) {
                    System.out.println("Producer [" + Thread.currentThread().getName() + "] interrupted.");
                    Thread.currentThread().interrupt(); // 重新设置中断状态
                }
            }
        };

        // --- 消费者任务 ---
        Runnable ConRunnable = new Runnable() {
            @Override
            public void run() {
                try {
                    while (true) { // 或者有明确的消费数量
                        int consumedItem = buffer.consume();
                        System.out.println("Consumer [" + Thread.currentThread().getName() + "] Consumed: " + consumedItem);
                        // 模拟消费耗时
                         Thread.sleep((long)(Math.random() * 1000)); // *** 加入随机休眠方便观察 ***
                    }
                // } catch (InterruptedException e) { // *** 捕获中断 ***
                //    System.out.println("Consumer [" + Thread.currentThread().getName() + "] interrupted.");
                //    Thread.currentThread().interrupt();
                } catch (InterruptedException e) { // 你的原始写法，也会中断线程
                    // throw new RuntimeException(e);
                    System.out.println("Consumer [" + Thread.currentThread().getName() + "] interrupted via RuntimeException propagation.");
                     Thread.currentThread().interrupt(); // 设置中断状态
                }
            }
        };

        // --- 启动线程 ---
        Thread ProThread1 = new Thread(ProRunnable, "Producer-1"); // *** 给线程命名 ***
        // Thread ProThread2 = new Thread(ProRunnable, "Producer-2"); // 可以启动多个生产者
        Thread ConThread1 = new Thread(ConRunnable, "Consumer-1");
        Thread ConThread2 = new Thread(ConRunnable, "Consumer-2"); // 可以启动多个消费者

        ProThread1.start();
        // ProThread2.start();
        ConThread1.start();
        ConThread2.start();

        // *** 注意：这个 main 方法会很快结束，但生产者消费者线程会继续运行 (因为是无限循环)
        // 实际应用中需要考虑如何优雅地停止这些线程 ***

    }
}

class Buffer{
    private final int capacity; // *** 使用 final 明确容量不变 ***
    private final LinkedList<Integer> bufferList; // *** 指定泛型类型 ***
    // private final Object lock = new Object(); // 可以用 this 作为锁，或者单独对象

    // *** 添加构造函数来设置容量 ***
    public Buffer(int capacity) {
        this.capacity = capacity;
        this.bufferList = new LinkedList<>();
    }


    public synchronized void produce(int item) throws InterruptedException { // *** 声明 InterruptedException ***
        // *** 1. 必须检查缓冲区是否已满 ***
        // *** 2. 必须使用 while 循环检查条件，防止虚假唤醒 ***
        while (bufferList.size() == capacity) {
             System.out.println("Producer [" + Thread.currentThread().getName() + "] Buffer FULL, waiting...");
             wait(); // 缓冲区满，等待并释放锁
        }
        // 缓冲区未满
        bufferList.add(item);
        // System.out.println("Producer [" + Thread.currentThread().getName() + "] Produced: " + item + " (Size: " + bufferList.size() + ")"); // 移到 Runnable 中打印

        // *** 3. 添加物品后必须通知等待的消费者 ***
        notifyAll(); // 唤醒所有等待的线程（生产者或消费者）
    }

    public synchronized int consume() throws InterruptedException {
        // *** 4. 必须使用 while 循环检查条件，防止虚假唤醒 ***
    
        // 缓冲区非空
        int item = bufferList.remove(); // remove() 默认移除第一个元素
        // System.out.println("Consumer [" + Thread.currentThread().getName() + "] Consumed: " + item + " (Size: " + bufferList.size() + ")"); // 移到 Runnable 中打印
    while(bufferList.size() == 0){ // 或者 bufferList.isEmpty()
             System.out.println("Consumer [" + Thread.currentThread().getName() + "] Buffer EMPTY, waiting...");
             wait(); // 缓冲区空，等待并释放锁
        }
        // *** 5. 取出物品后必须通知等待的生产者 ***
        notifyAll(); // 唤醒所有等待的线程
        return item;
    }
}
```
---

## 练习 10：使用 ExecutorService (线程池)

*   **目标**：学习使用 Java 标准库提供的线程池来管理和执行任务，避免手动创建线程。
*   **要求**：
    1.  回顾练习 6 或 7 中的 `Runnable` 任务（给 `Counter` 递增的任务）。
    2.  在 `main` 方法中：
        *   不再手动创建 10 个 `Thread` 实例。
        *   使用 `Executors.newFixedThreadPool(int nThreads)` 创建一个固定大小的线程池（例如，大小为 4）。
        *   创建一个共享的 `Counter` 实例。
        *   循环 10 次，每次创建一个 `Runnable` 任务实例，并使用 `executorService.submit(Runnable task)` 将任务提交给线程池执行。
        *   **重要**：任务提交后，需要关闭线程池。先调用 `executorService.shutdown()`（不再接受新任务，等待已提交任务完成），然后可以调用 `executorService.awaitTermination(long timeout, TimeUnit unit)` 来等待线程池完全终止。
        *   打印最终的 `counter.getCount()` 的值（如果使用了练习 7 的同步 `Counter`，结果应该是 100000）。
    3.  **思考**：使用线程池与手动创建线程相比，代码有何变化？有什么好处？


好的，我们来逐个解答练习 6 到 10 的问题和代码。

---

## 练习 6：理解竞态条件 (Race Condition)

*   **目标**：亲身体验多线程访问共享资源时可能出现的问题，理解为何需要同步。
*   **要求**：
    1.  创建一个类 `Counter`，它有一个实例变量 `private int count = 0;` 和一个 `increment()` 方法，该方法执行 `count++`。再添加一个 `getCount()` 方法返回 `count` 的值。
    2.  创建一个 `Runnable` 任务，在其 `run()` 方法中，循环调用 `Counter` 对象的 `increment()` 方法 10000 次。
    3.  在 `main` 方法中：
        *   创建一个共享的 `Counter` 实例。
        *   创建并启动 10 个线程，每个线程都执行上述的 `Runnable` 任务（操作同一个 `Counter` 实例）。
        *   使用 `join()` 等待所有这 10 个线程都执行完毕。
        *   打印最终 `counter.getCount()` 的值。
    4.  **思考与观察**：
        *   预期的最终 `count` 值应该是多少？ (10 * 10000 = 100000)
        *   多次运行程序，观察实际打印的最终 `count` 值是多少？它是否总是等于预期值？为什么会出现这种情况？（提示：`count++` 不是原子操作）

**答案:**

```java
public class Exercise6 {

    static class Counter {
        private int count = 0;

        // 非线程安全的方法
        public void increment() {
            count++; // 这不是原子操作！
        }

        public int getCount() {
            return count;
        }
    }

    static class IncrementTask implements Runnable {
        private Counter counter;

        public IncrementTask(Counter counter) {
            this.counter = counter;
        }

        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println("Main thread started.");
        Counter sharedCounter = new Counter(); // 共享的 Counter 实例
        int numThreads = 10;

        Thread[] threads = new Thread[numThreads];
        for (int i = 0; i < numThreads; i++) {
            threads[i] = new Thread(new IncrementTask(sharedCounter), "CounterThread-" + i);
            threads[i].start();
        }

        System.out.println("Main thread waiting for counter threads to finish...");
        for (Thread t : threads) {
            t.join(); // 等待所有线程执行完毕
        }

        System.out.println("All counter threads finished.");
        // 打印最终结果
        System.out.println("Expected final count: 100000");
        System.out.println("Actual final count:   " + sharedCounter.getCount()); // 很可能小于 100000
        System.out.println("Main thread finished.");
    }
}
```

**思考与观察解答**：

*   **预期值**：100000 (10 个线程，每个线程增加 10000 次)。
*   **实际值**：多次运行会发现，实际打印的 `count` 值几乎**总是小于 100000**，并且每次运行的结果可能都不同。
*   **原因**：`count++` 这个操作看起来简单，但它在字节码层面（甚至在 CPU 指令层面）通常包含三个步骤：
    1.  **读取** `count` 的当前值到工作内存（或寄存器）。
    2.  将读取到的值**加 1**。
    3.  将计算后的新值**写回** `count` 变量（写回主内存）。
    由于这三个步骤不是**原子**的，多个线程并发执行 `increment()` 时，可能会发生以下情况（竞态条件）：
    *   线程 A 读取 `count` (假设为 5)。
    *   线程 B 也读取 `count` (也读取到 5)。
    *   线程 A 计算 5 + 1 = 6，并将 6 写回 `count`。
    *   线程 B 计算 5 + 1 = 6，并将 6 写回 `count`。
    虽然两个线程都执行了 `increment()`，但 `count` 最终只增加了 1（变成了 6），而不是期望的增加 2（变成 7）。这种读写冲突导致了最终结果丢失了一部分增量。

---

## 练习 7：使用 synchronized 解决竞态条件

*   **目标**：学习使用 `synchronized` 关键字保护共享资源，解决练习 6 中出现的问题。
*   **要求**：
    1.  基于练习 6 的代码。
    2.  修改 `Counter` 类的 `increment()` 方法和 `getCount()` 方法（或者只修改 `increment`，取决于你认为哪里需要保护），使用 `synchronized` 关键字来保证对 `count` 变量访问的原子性和可见性。你可以选择同步整个方法，或者使用 `synchronized(this)` 代码块。
    3.  再次运行 `main` 方法多次。
    4.  **观察**：现在最终的 `count` 值是否总是等于预期值 100000？ `synchronized` 是如何解决问题的？

**答案:**

```java
// 修改 Counter 类
class SynchronizedCounter {
    private int count = 0;

    // 使用 synchronized 修饰实例方法，锁是 this 对象
    public synchronized void increment() {
        count++; // 现在这个操作是原子的，且对其他线程可见
    }

    // 读取操作最好也加上 synchronized，保证可见性
    // (虽然在这个特定例子里，由于 join() 的 happens-before 保证，
    //  即使 getCount() 不加 synchronized 可能也能看到正确结果，
    //  但加锁是更严谨的做法)
    public synchronized int getCount() {
        return count;
    }

    // 或者使用同步代码块 (效果相同)
    /*
    private final Object lock = new Object(); // 可以创建一个专门的锁对象
    public void increment() {
        synchronized (this) { // 或 synchronized(lock)
            count++;
        }
    }
    public int getCount() {
        synchronized (this) { // 或 synchronized(lock)
            return count;
        }
    }
    */
}

// IncrementTask 和 main 方法与练习 6 基本相同，只是使用 SynchronizedCounter
public class Exercise7 {

    static class IncrementTask implements Runnable {
        private SynchronizedCounter counter; // 使用同步版本的 Counter

        public IncrementTask(SynchronizedCounter counter) {
            this.counter = counter;
        }

        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println("Main thread started.");
        SynchronizedCounter sharedCounter = new SynchronizedCounter(); // 使用同步 Counter
        int numThreads = 10;

        Thread[] threads = new Thread[numThreads];
        for (int i = 0; i < numThreads; i++) {
            threads[i] = new Thread(new IncrementTask(sharedCounter), "SyncCounterThread-" + i);
            threads[i].start();
        }

        System.out.println("Main thread waiting for counter threads to finish...");
        for (Thread t : threads) {
            t.join();
        }

        System.out.println("All counter threads finished.");
        System.out.println("Expected final count: 100000");
        System.out.println("Actual final count:   " + sharedCounter.getCount()); // 现在应该是 100000
        System.out.println("Main thread finished.");
    }
}
```

**观察解答**：

*   现在多次运行程序，最终的 `count` 值**总是等于 100000**。
*   **`synchronized` 如何解决问题**：
    1.  **互斥性/原子性**：`synchronized` 关键字保证了 `increment()` 方法（或同步块）在同一时刻只能被一个线程执行。当一个线程进入 `increment()` 时，它会获取 `sharedCounter` 对象（`this`）的锁，其他线程如果想进入 `increment()`（或同一个对象的其他 `synchronized` 方法/块），就必须等待该线程释放锁。这使得 `count++` 的“读-改-写”三个步骤作为一个不可分割的原子单元执行，不会被其他线程干扰。
    2.  **可见性**：当一个线程退出 `synchronized` 方法/块（释放锁）时，JMM 会保证它对共享变量（`count`）的修改刷新到主内存。当另一个线程进入同一个 `synchronized` 方法/块（获取锁）时，JMM 会保证它从主内存读取最新的共享变量值。这确保了一个线程对 `count` 的修改对后续获取锁的线程是可见的。

---

## 练习 8：使用 `volatile` 实现状态标志

*   **目标**：理解 `volatile` 在保证可见性方面的作用，适用于简单的状态控制。
*   **要求**：
    1.  创建一个 `Worker` 类实现 `Runnable`。
    2.  `Worker` 类有一个 `private volatile boolean running = true;` 实例变量。
    3.  `run()` 方法包含一个 `while(running)` 循环，在循环中打印 "Worker is running..." 并短暂 `sleep`（例如 200 毫秒）。
    4.  `Worker` 类提供一个 `public void stopWorker()` 方法，该方法将 `running` 设置为 `false`。
    5.  在 `main` 方法中：
        *   创建 `Worker` 实例。
        *   创建并启动一个线程来运行 `Worker` 任务。
        *   让 `main` 线程 `sleep` 1 秒钟。
        *   调用 `worker.stopWorker()` 方法。
        *   观察 worker 线程是否能够正常停止。

**答案:**

```java
import java.util.concurrent.TimeUnit;

class VolatileWorker implements Runnable {
    // 使用 volatile 保证可见性
    private volatile boolean running = true;

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        System.out.println("[" + threadName + "] Worker started.");
        while (running) { // 读取 volatile 变量
            System.out.println("[" + threadName + "] Worker is running...");
            try {
                // 短暂休眠，模拟工作，也让主线程有机会执行 stopWorker
                TimeUnit.MILLISECONDS.sleep(200);
            } catch (InterruptedException e) {
                // 如果在 sleep 时被中断，也应该停止
                System.out.println("[" + threadName + "] Worker interrupted during sleep, stopping.");
                // 不需要设置 running = false，因为中断也意味着要停止
                Thread.currentThread().interrupt(); // 保持中断状态
                break; // 退出循环
            }
        }
        System.out.println("[" + threadName + "] Worker stopped.");
    }

    public void stopWorker() {
        System.out.println("[Main thread] Requesting worker to stop...");
        this.running = false; // 写入 volatile 变量
    }
}

public class Exercise8 {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("Main thread started.");

        VolatileWorker workerTask = new VolatileWorker();
        Thread workerThread = new Thread(workerTask, "VolatileWorkerThread");
        workerThread.start();

        // 让 worker 线程运行 1 秒
        TimeUnit.SECONDS.sleep(1);

        // 从主线程请求停止 worker 线程
        workerTask.stopWorker();

        // (可选) 等待 worker 线程真正结束
        workerThread.join();
        System.out.println("Worker thread joined.");

        System.out.println("Main thread finished.");
    }
}
```

**观察解答**：

*   运行程序，会看到 worker 线程打印 "Worker is running..." 几次后，在 `main` 线程调用 `stopWorker()` 将 `running` 设置为 `false` 后，worker 线程能够检测到 `running` 值的变化，退出 `while` 循环，并打印 "Worker stopped."。
*   **`volatile` 的作用**：
    *   当 `main` 线程执行 `workerTask.stopWorker()`，写入 `running = false;` 时，`volatile` 关键字保证了这个新值 (`false`) 会被立即强制写回主内存。
    *   当 `workerThread` 在下一次循环判断 `while(running)` 时，`volatile` 关键字保证了它会强制从主内存中读取 `running` 的最新值，而不是使用自己工作内存中可能存在的旧值 (`true`)。
    *   这样就确保了 `main` 线程对 `running` 标志的修改能够及时被 `workerThread` 看到，从而实现了线程的正常停止。
    *   如果没有 `volatile`，`workerThread` 可能会因为 CPU 缓存等原因一直读取到旧的 `running` 值 (`true`)，导致无法停止（活性问题）。

---

## 练习 9：使用 `wait()` / `notify()` 实现生产者-消费者

*   **目标**：学习使用 `Object` 的 `wait()`, `notify()` (或 `notifyAll()`) 方法进行线程间通信，实现经典的生产者-消费者模式。
*   **要求**：(见上文)

**答案:**

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.TimeUnit;

class SharedBuffer {
    private final Queue<Integer> buffer;
    private final int capacity;
    private final Object lock = new Object(); // 用于同步和 wait/notify

    public SharedBuffer(int capacity) {
        this.buffer = new LinkedList<>();
        this.capacity = capacity;
    }

    public void produce(int item) throws InterruptedException {
        synchronized (lock) {
            // 使用 while 检查条件，防止虚假唤醒
            while (buffer.size() == capacity) {
                System.out.println("Producer [" + Thread.currentThread().getName() + "] Buffer is FULL, waiting...");
                lock.wait(); // 缓冲区满，生产者等待，并释放锁
            }
            // 缓冲区未满，生产物品
            buffer.offer(item);
            System.out.println("Producer [" + Thread.currentThread().getName() + "] Produced: " + item + " (Buffer size: " + buffer.size() + ")");
            // 唤醒可能在等待的消费者
            // 使用 notifyAll() 更健壮，可以唤醒所有等待的线程（生产者或消费者）
            // 如果确定只有一个消费者或生产者在等待，notify() 也可以，但 notifyAll 更安全
            lock.notifyAll();
        }
    }

    public int consume() throws InterruptedException {
        synchronized (lock) {
            // 使用 while 检查条件
            while (buffer.isEmpty()) {
                System.out.println("Consumer [" + Thread.currentThread().getName() + "] Buffer is EMPTY, waiting...");
                lock.wait(); // 缓冲区空，消费者等待，并释放锁
            }
            // 缓冲区非空，消费物品
            int item = buffer.poll();
            System.out.println("Consumer [" + Thread.currentThread().getName() + "] Consumed: " + item + " (Buffer size: " + buffer.size() + ")");
            // 唤醒可能在等待的生产者
            lock.notifyAll();
            return item;
        }
    }
}

class Producer implements Runnable {
    private final SharedBuffer sharedBuffer;
    private final Random random = new Random();

    public Producer(SharedBuffer sharedBuffer) {
        this.sharedBuffer = sharedBuffer;
    }

    @Override
    public void run() {
        try {
            for (int i = 0; i < 10; i++) { // 生产 10 个物品
                sharedBuffer.produce(i);
                // 模拟生产耗时
                TimeUnit.MILLISECONDS.sleep(random.nextInt(500));
            }
            System.out.println("Producer [" + Thread.currentThread().getName() + "] finished producing.");
        } catch (InterruptedException e) {
            System.out.println("Producer [" + Thread.currentThread().getName() + "] interrupted.");
            Thread.currentThread().interrupt();
        }
    }
}

class Consumer implements Runnable {
    private final SharedBuffer sharedBuffer;
    private final Random random = new Random();

    public Consumer(SharedBuffer sharedBuffer) {
        this.sharedBuffer = sharedBuffer;
    }

    @Override
    public void run() {
         try {
            for (int i = 0; i < 10; i++) { // 消费 10 个物品
                sharedBuffer.consume();
                 // 模拟消费耗时
                TimeUnit.MILLISECONDS.sleep(random.nextInt(1000));
            }
             System.out.println("Consumer [" + Thread.currentThread().getName() + "] finished consuming.");
        } catch (InterruptedException e) {
            System.out.println("Consumer [" + Thread.currentThread().getName() + "] interrupted.");
            Thread.currentThread().interrupt();
        }
    }
}


public class Exercise9 {
    public static void main(String[] args) {
        System.out.println("Main thread started.");
        SharedBuffer buffer = new SharedBuffer(5); // 容量为 5 的缓冲区

        Thread producer1 = new Thread(new Producer(buffer), "Producer-1");
        Thread consumer1 = new Thread(new Consumer(buffer), "Consumer-1");
        Thread consumer2 = new Thread(new Consumer(buffer), "Consumer-2"); // 可以有多个消费者

        producer1.start();
        consumer1.start();
        consumer2.start(); // 启动第二个消费者

        // 让它们运行一段时间，实际应用中可能需要 join 或其他结束机制
        try {
            producer1.join();
            // 注意：这里简单 join 生产者，消费者可能还没消费完所有产品
            // 更好的方式是让生产者生产完后发出信号，或者消费者消费固定数量后停止
            System.out.println("Producer finished, waiting a bit for consumers...");
            TimeUnit.SECONDS.sleep(5); // 等待消费者消费
            // 尝试中断消费者（如果它们还在运行）
            consumer1.interrupt();
            consumer2.interrupt();
            consumer1.join();
            consumer2.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }


        System.out.println("Main thread finished.");
    }
}
```

**关键点解释**：

*   **`synchronized(lock)`**：确保了 `produce` 和 `consume` 方法内部对共享 `buffer` 的访问是互斥的，避免了同时添加/删除元素导致的数据结构损坏。同时，`wait()` 和 `notifyAll()` **必须** 在获取到对象的锁（这里是 `lock` 对象）之后才能调用。
*   **`while (condition)` + `wait()`**：当条件不满足时（缓冲区满或空），线程调用 `lock.wait()`。这会使当前线程**释放 `lock` 锁**并进入等待状态 (`WAITING`)。使用 `while` 而不是 `if` 是为了防止**虚假唤醒**——即使没有调用 `notify/notifyAll`，线程也可能偶尔被唤醒。`while` 循环确保了线程被唤醒后**再次检查条件**是否真的满足，如果不满足则继续 `wait()`。
*   **`lock.notifyAll()`**：当线程修改了条件（生产了物品或消费了物品）后，调用 `notifyAll()` 来唤醒**所有**在该 `lock` 对象上等待的线程（包括其他生产者和消费者）。被唤醒的线程会尝试重新获取 `lock` 锁，获取成功后从 `wait()` 返回，然后再次检查 `while` 循环的条件。使用 `notifyAll()` 通常比 `notify()` 更安全，虽然可能效率稍低（唤醒了不需要唤醒的线程），但避免了信号丢失的问题（例如，只唤醒了一个生产者，但其实消费者也可以运行了）。

---

## 练习 10：使用 ExecutorService (线程池)

*   **目标**：学习使用 Java 标准库提供的线程池来管理和执行任务，避免手动创建线程。
*   **要求**：(见上文)

**答案:**

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

// 使用练习 7 的 SynchronizedCounter
class SynchronizedCounter {
    private int count = 0;
    public synchronized void increment() { count++; }
    public synchronized int getCount() { return count; }
}

public class Exercise10 {

    // 任务与练习 7 相同
    static class IncrementTask implements Runnable {
        private SynchronizedCounter counter;

        public IncrementTask(SynchronizedCounter counter) {
            this.counter = counter;
        }

        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
             // 可以在这里打印线程名，观察线程复用
             // System.out.println("Task finished in thread: " + Thread.currentThread().getName());
        }
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println("Main thread started.");
        SynchronizedCounter sharedCounter = new SynchronizedCounter();
        int numTasks = 10; // 总共有 10 个任务
        int poolSize = 4;  // 线程池大小为 4

        // 1. 创建固定大小的线程池
        ExecutorService executorService = Executors.newFixedThreadPool(poolSize);
        System.out.println("Created fixed thread pool with size: " + poolSize);

        // 2. 提交任务给线程池
        System.out.println("Submitting " + numTasks + " tasks to the thread pool...");
        for (int i = 0; i < numTasks; i++) {
            executorService.submit(new IncrementTask(sharedCounter));
        }
        System.out.println("All tasks submitted.");

        // 3. 关闭线程池
        // shutdown()：平滑关闭，不再接受新任务，等待已提交任务执行完成
        System.out.println("Shutting down the executor service...");
        executorService.shutdown();

        // 可选：等待线程池完全终止 (或者超时)
        try {
            System.out.println("Waiting for termination...");
            // 等待最多 1 分钟，如果超时还没结束就不再等待
            if (!executorService.awaitTermination(1, TimeUnit.MINUTES)) {
                System.err.println("Executor service did not terminate in the specified time.");
                // 可以选择强制关闭：executorService.shutdownNow();
            } else {
                 System.out.println("Executor service terminated successfully.");
            }
        } catch (InterruptedException e) {
            System.err.println("Main thread interrupted while waiting for termination.");
            // (重新)中断所有任务并关闭 ExecutorService
            executorService.shutdownNow();
            // 保留中断状态
            Thread.currentThread().interrupt();
        }

        System.out.println("All tasks should be completed.");
        System.out.println("Expected final count: 100000");
        System.out.println("Actual final count:   " + sharedCounter.getCount()); // 应该是 100000
        System.out.println("Main thread finished.");
    }
}
```

**思考解答**：

*   **代码变化**：
    *   不再需要手动创建 `Thread` 对象数组。
    *   不再需要手动调用 `thread.start()`。
    *   不再需要手动调用 `thread.join()` 来等待每个线程结束（而是通过 `shutdown()` 和 `awaitTermination()` 来管理整个线程池的生命周期）。
    *   创建线程的逻辑被 `Executors.newFixedThreadPool()` 封装了。
    *   执行任务的逻辑变成了向 `executorService` 提交 `Runnable` 任务。
*   **好处**：
    *   **简化了线程管理**：开发者不需要关心线程的创建、启动、销毁和复用细节，只需关注任务本身。
    *   **提高了性能**：通过复用线程，避免了频繁创建和销毁线程带来的开销。
    *   **控制了并发数**：`newFixedThreadPool(4)` 限制了最多只有 4 个线程同时执行任务，防止了因线程过多导致系统资源耗尽或性能下降。
    *   **更健壮**：线程池提供了更好的资源管理和错误处理机制。
    *   **代码更清晰**：将任务提交与任务执行解耦。

---

## 练习 11：使用 `ReentrantLock` 和 `Condition` 实现生产者-消费者

*   **目标**：掌握 `ReentrantLock` 显式锁和 `Condition` 条件变量的使用，作为 `synchronized`/`wait`/`notify` 的替代方案。
*   **要求**：
    1.  重构练习 9 的 `Buffer` 类。
    2.  使用 `java.util.concurrent.locks.ReentrantLock` 替代 `synchronized` 关键字来保护缓冲区。
    3.  创建两个 `java.util.concurrent.locks.Condition` 实例，一个用于缓冲区不满 (`notFull`)，一个用于缓冲区不空 (`notEmpty`)。
    4.  在 `produce` 方法中：
        *   获取锁 (`lock.lock()`)。
        *   使用 `while` 循环检查缓冲区是否已满，如果满了，调用 `notFull.await()` 等待。
        *   添加物品。
        *   调用 `notEmpty.signal()` 或 `notEmpty.signalAll()` 唤醒等待的消费者。
        *   在 `finally` 块中释放锁 (`lock.unlock()`)。
    5.  在 `consume` 方法中：
        *   获取锁 (`lock.lock()`)。
        *   使用 `while` 循环检查缓冲区是否为空，如果空了，调用 `notEmpty.await()` 等待。
        *   取出物品。
        *   调用 `notFull.signal()` 或 `notFull.signalAll()` 唤醒等待的生产者。
        *   在 `finally` 块中释放锁 (`lock.unlock()`)。
    6.  `main` 方法部分与练习 9 类似，使用这个新的 `Buffer` 类启动生产者和消费者。

回答:
```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

// 使用 ReentrantLock 和 Condition 实现的 Buffer
class ReentrantLockBuffer {
    private final Queue<Integer> buffer;
    private final int capacity;
    private final Lock lock = new ReentrantLock(); // 使用 ReentrantLock
    private final Condition notFull = lock.newCondition(); // 条件：缓冲区不满
    private final Condition notEmpty = lock.newCondition(); // 条件：缓冲区不空

    public ReentrantLockBuffer(int capacity) {
        this.buffer = new LinkedList<>();
        this.capacity = capacity;
    }

    public void produce(int item) throws InterruptedException {
        lock.lock(); // 获取锁
        try {
            // 使用 while 检查条件
            while (buffer.size() == capacity) {
                System.out.println("Producer [" + Thread.currentThread().getName() + "] Buffer is FULL, waiting on notFull...");
                notFull.await(); // 缓冲区满，等待在 notFull 条件上，并释放锁
            }
            // 缓冲区未满
            buffer.offer(item);
            // System.out.println("Producer [" + Thread.currentThread().getName() + "] Produced: " + item + " (Size: " + buffer.size() + ")");

            // 唤醒等待在 notEmpty 条件上的消费者线程
            System.out.println("Producer [" + Thread.currentThread().getName() + "] Signalling notEmpty...");
            notEmpty.signal(); // 或者 signalAll()，这里 signal() 通常足够，因为只生产了一个
        } finally {
            lock.unlock(); // 必须在 finally 块中释放锁
        }
    }

    public int consume() throws InterruptedException {
        lock.lock(); // 获取锁
        try {
            // 使用 while 检查条件
            while (buffer.isEmpty()) {
                System.out.println("Consumer [" + Thread.currentThread().getName() + "] Buffer is EMPTY, waiting on notEmpty...");
                notEmpty.await(); // 缓冲区空，等待在 notEmpty 条件上，并释放锁
            }
            // 缓冲区非空
            int item = buffer.poll();
           // System.out.println("Consumer [" + Thread.currentThread().getName() + "] Consumed: " + item + " (Size: " + buffer.size() + ")");

            // 唤醒等待在 notFull 条件上的生产者线程
             System.out.println("Consumer [" + Thread.currentThread().getName() + "] Signalling notFull...");
            notFull.signal(); // 或者 signalAll()
            return item;
        } finally {
            lock.unlock(); // 必须在 finally 块中释放锁
        }
    }
}

// Producer 和 Consumer 类与练习 9 基本相同，只是它们现在接收 ReentrantLockBuffer
class ProducerRL implements Runnable {
    private final ReentrantLockBuffer buffer;
    private int itemToProduce = 0;
    private final Random random = new Random();

    public ProducerRL(ReentrantLockBuffer buffer) { this.buffer = buffer; }

    @Override
    public void run() {
        try {
            while(true) {
                buffer.produce(itemToProduce);
                System.out.println("Producer [" + Thread.currentThread().getName() + "] Produced: " + itemToProduce);
                itemToProduce++;
                TimeUnit.MILLISECONDS.sleep(random.nextInt(500));
            }
        } catch (InterruptedException e) {
             System.out.println("Producer [" + Thread.currentThread().getName() + "] interrupted.");
             Thread.currentThread().interrupt();
        }
    }
}

class ConsumerRL implements Runnable {
     private final ReentrantLockBuffer buffer;
     private final Random random = new Random();

    public ConsumerRL(ReentrantLockBuffer buffer) { this.buffer = buffer; }

    @Override
    public void run() {
        try {
             while(true) {
                int consumedItem = buffer.consume();
                System.out.println("Consumer [" + Thread.currentThread().getName() + "] Consumed: " + consumedItem);
                TimeUnit.MILLISECONDS.sleep(random.nextInt(1000));
             }
        } catch (InterruptedException e) {
            System.out.println("Consumer [" + Thread.currentThread().getName() + "] interrupted.");
            Thread.currentThread().interrupt();
        }
    }
}

public class Exercise11 {
    public static void main(String[] args) {
        System.out.println("Main thread started (ReentrantLock version).");
        ReentrantLockBuffer buffer = new ReentrantLockBuffer(5);

        Thread producer1 = new Thread(new ProducerRL(buffer), "ProducerRL-1");
        Thread consumer1 = new Thread(new ConsumerRL(buffer), "ConsumerRL-1");
        Thread consumer2 = new Thread(new ConsumerRL(buffer), "ConsumerRL-2");

        producer1.start();
        consumer1.start();
        consumer2.start();

        // 同样需要考虑如何优雅停止
        try {
            TimeUnit.SECONDS.sleep(10); // 运行 10 秒
            producer1.interrupt();
            consumer1.interrupt();
            consumer2.interrupt();
            producer1.join();
            consumer1.join();
            consumer2.join();
        } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
        }

        System.out.println("Main thread finished.");
    }
}
```
关键点对比 synchronized/wait/notify：
锁获取/释放更明确：必须手动调用 lock() 和 unlock()，并且 unlock() 通常放在 finally 块中，确保锁一定会被释放。
条件分离：可以使用 newCondition() 创建多个 Condition 对象，将不同等待条件（如“不满”和“不空”）分开，可以实现更精确的唤醒（只唤醒等待特定条件的线程，使用 signal()），可能比 notifyAll() 效率更高。
功能更强大：ReentrantLock 提供了更多高级功能，如可中断锁 (lockInterruptibly())、尝试获取锁 (tryLock())、公平锁等。

问:为什么要中断,然后再join呢?

答:
1.  **`TimeUnit.SECONDS.sleep(10);`**: 主线程在这里暂停 10 秒，是为了让生产者和消费者线程有足够的时间运行起来，进行一些生产和消费的操作，让我们能观察到它们交替工作的现象。

2.  **`producer1.interrupt(); consumer1.interrupt(); consumer2.interrupt();`**:
    *   **目的**：因为生产者和消费者的 `run` 方法里是 `while(true)` 无限循环（或者一个固定但可能很长的循环），它们自己不会主动停止。如果不干预，`main` 线程后面的 `join()` 会永远等待下去。所以，在主线程等待了 10 秒（让它们跑一会儿）之后，需要一种方法来**请求**这些工作线程**停止**。
    *   **机制**：调用线程的 `interrupt()` 方法就是发送一个“中断请求”信号。
    *   **响应**：在 `ProducerRL` 和 `ConsumerRL` 的 `run` 方法中，它们内部调用了 `buffer.produce()` 或 `buffer.consume()`，而这两个方法内部又可能调用 `notFull.await()` 或 `notEmpty.await()`，或者它们在循环中调用了 `TimeUnit.MILLISECONDS.sleep()`。这些方法 (`await()`, `sleep()`) 都会**响应中断**。当一个线程在 `await()` 或 `sleep()` 中被中断时，这些方法会抛出 `InterruptedException`。
    *   **结果**：我们在 `ProducerRL` 和 `ConsumerRL` 的 `run` 方法的 `catch (InterruptedException e)` 块中处理了这个异常，通常是打印一条消息，然后（通过 `break` 或方法结束）**终止线程的执行**。

3.  **`producer1.join(); consumer1.join(); consumer2.join();`**:
    *   **目的**：仅仅调用 `interrupt()` 只是发送了停止请求，线程可能还需要一点点时间来响应中断、执行 `catch` 块、退出 `run` 方法。主线程调用 `join()` 是为了**确保**这些工作线程**真正完全终止**之后，主线程才继续往下执行（打印 "Main thread finished."）。
    *   **效果**：`join()` 会阻塞主线程，直到被 `join` 的那个线程（比如 `producer1`）的 `run` 方法执行完毕。

**总结：**

这个 `interrupt()` 然后 `join()` 的模式在这里是一种**控制和清理**演示代码的方式：

*   先让子线程跑一会儿，展示生产者-消费者模式。
*   然后通过 `interrupt()` **请求**它们停止（因为它们自己是无限循环的）。
*   最后通过 `join()` **等待**它们确实停止了，这样 `main` 线程才能干净利落地结束，而不是在子线程还在运行时就退出了。

如果没有 `interrupt()`，`join()` 会永久阻塞。如果没有 `join()`，`main` 线程可能在子线程还没完全响应中断并退出前就结束了。

---

## 练习 12：使用 `BlockingQueue` 实现生产者-消费者 (推荐方式)

*   **目标**：学习使用 JUC 提供的 `BlockingQueue` 接口（如 `ArrayBlockingQueue`），以**极其简洁**的方式实现生产者-消费者模式。这是**实际开发中最常用、最推荐**的方式。
*   **要求**：
    1.  **不需要** 手动创建 `Buffer` 类。
    2.  在 `main` 方法中，创建一个 `java.util.concurrent.ArrayBlockingQueue<Integer>` 实例，指定容量（例如 5）。
    3.  修改 `Producer` 的 `run` 方法：
        *   不需要显式锁或等待。
        *   直接调用 `blockingQueue.put(item)` 方法将物品放入队列。`put` 方法会在队列满时**自动阻塞**生产者线程，直到队列有空间为止。
    4.  修改 `Consumer` 的 `run` 方法：
        *   不需要显式锁或等待。
        *   直接调用 `int item = blockingQueue.take()` 方法从队列取出物品。`take` 方法会在队列空时**自动阻塞**消费者线程，直到队列有物品为止。
    5.  启动生产者和消费者线程，观察运行情况。体会代码量相比练习 9 和 11 的巨大减少。


答案:
```java
import java.util.Random;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

// 生产者类
class ProducerBQ implements Runnable {
    private final BlockingQueue<Integer> queue; // 使用 BlockingQueue
    private int itemToProduce = 0;
    private final Random random = new Random();

    public ProducerBQ(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            while (true) { // 或者有明确生产数量
                System.out.println("Producer [" + Thread.currentThread().getName() + "] attempting to put: " + itemToProduce);
                queue.put(itemToProduce); // 队列满时自动阻塞
                System.out.println("Producer [" + Thread.currentThread().getName() + "] Successfully put: " + itemToProduce + " (Queue size: " + queue.size() + ")");
                itemToProduce++;
                TimeUnit.MILLISECONDS.sleep(random.nextInt(500)); // 模拟生产耗时
            }
        } catch (InterruptedException e) {
            System.out.println("Producer [" + Thread.currentThread().getName() + "] interrupted.");
            Thread.currentThread().interrupt();
        }
    }
}

// 消费者类
class ConsumerBQ implements Runnable {
    private final BlockingQueue<Integer> queue;
    private final Random random = new Random();

    public ConsumerBQ(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            while (true) { // 或者有明确消费数量
                System.out.println("Consumer [" + Thread.currentThread().getName() + "] attempting to take...");
                int consumedItem = queue.take(); // 队列空时自动阻塞
                System.out.println("Consumer [" + Thread.currentThread().getName() + "] Successfully took: " + consumedItem + " (Queue size: " + queue.size() + ")");
                TimeUnit.MILLISECONDS.sleep(random.nextInt(1000)); // 模拟消费耗时
            }
        } catch (InterruptedException e) {
             System.out.println("Consumer [" + Thread.currentThread().getName() + "] interrupted.");
            Thread.currentThread().interrupt();
        }
    }
}

public class Exercise12 {
    public static void main(String[] args) {
        System.out.println("Main thread started (BlockingQueue version).");
        int capacity = 5;
        // 创建有界阻塞队列
        BlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<>(capacity);

        Thread producer1 = new Thread(new ProducerBQ(blockingQueue), "ProducerBQ-1");
        Thread consumer1 = new Thread(new ConsumerBQ(blockingQueue), "ConsumerBQ-1");
        Thread consumer2 = new Thread(new ConsumerBQ(blockingQueue), "ConsumerBQ-2");

        producer1.start();
        consumer1.start();
        consumer2.start();

        // 同样需要考虑优雅停止
         try {
            TimeUnit.SECONDS.sleep(10); // 运行 10 秒
            producer1.interrupt();
            consumer1.interrupt();
            consumer2.interrupt();
            producer1.join();
            consumer1.join();
            consumer2.join();
        } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
        }

        System.out.println("Main thread finished.");
    }
}
```

体会：
使用 BlockingQueue 后，生产者和消费者代码变得极其简单。
不再需要手动管理锁、条件变量、wait/notify/await/signal，BlockingQueue 内部封装了所有这些复杂的同步逻辑，开发者只需要调用 put() 和 take() 即可实现线程安全的、阻塞式的生产和消费。
这是强烈推荐的实现方式。
---

## 练习 13：使用 `ExecutorService` 和 `Callable`/`Future` 并行计算

*   **目标**：练习使用线程池执行**有返回值**的任务，并获取任务结果。模拟并行处理一组计算任务。
*   **要求**：
    1.  创建一个 `FactorialCalculator` 类实现 `Callable<Long>` 接口。`Callable` 的泛型表示 `call()` 方法的返回值类型。
    2.  `FactorialCalculator` 接收一个整数 `number` 作为构造参数。
    3.  在其 `call()` 方法中，计算 `number` 的阶乘，并返回 `Long` 类型的结果。为了模拟耗时，可以在计算中加入少量 `sleep`。处理小于 0 的输入的异常情况。
    4.  在 `main` 方法中：
        *   创建一个 `ExecutorService` (例如 `Executors.newFixedThreadPool(4)`）。
        *   定义一个要计算阶乘的数字列表（例如 `[5, 8, 10, 12, 15, 20]`）。
        *   创建一个 `List<Future<Long>>` 来存储提交任务后返回的 `Future` 对象。
        *   遍历数字列表，为每个数字创建一个 `FactorialCalculator` 任务，并使用 `executorService.submit(callableTask)` 提交给线程池，将返回的 `Future` 加入 `futures` 列表。
        *   **按顺序** 遍历 `futures` 列表，对每个 `future` 调用 `future.get()` 来获取计算结果。`get()` 方法会阻塞，直到该任务完成并返回结果。
        *   打印每个数字及其对应的阶乘结果。注意处理 `get()` 可能抛出的 `InterruptedException` 和 `ExecutionException`（后者包装了 `call()` 方法中抛出的异常）。
        *   最后，记得关闭 `ExecutorService`。

答案:
```Java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.*;

// 计算阶乘的任务
class FactorialCalculator implements Callable<Long> {
    private final int number;

    public FactorialCalculator(int number) {
        if (number < 0) {
            throw new IllegalArgumentException("Number must be non-negative.");
        }
        this.number = number;
    }

    @Override
    public Long call() throws Exception { // 注意 call() 方法可以抛出 Exception
        long result = 1L;
        if (number == 0 || number == 1) {
            result = 1L;
        } else {
            for (int i = 2; i <= number; i++) {
                result *= i;
                // 模拟耗时
                // TimeUnit.MILLISECONDS.sleep(10); // 不要 sleep 太久，否则阶乘计算会非常慢
            }
        }
         System.out.println("Factorial of " + number + " calculated by " + Thread.currentThread().getName());
        return result;
    }
}

public class Exercise13 {
    public static void main(String[] args) {
        System.out.println("Main thread started (Callable/Future version).");
        int poolSize = 4;
        ExecutorService executorService = Executors.newFixedThreadPool(poolSize);

        List<Integer> numbersToCalculate = Arrays.asList(5, 8, 10, 12, 15, 0, -2, 20); // 加入 0 和负数测试
        List<Future<Long>> futures = new ArrayList<>();

        System.out.println("Submitting factorial tasks...");
        for (int number : numbersToCalculate) {
            FactorialCalculator task = new FactorialCalculator(number);
            Future<Long> future = executorService.submit(task);
            futures.add(future);
        }
        System.out.println("All tasks submitted.");

        // 获取结果
        System.out.println("Retrieving results...");
        for (int i = 0; i < numbersToCalculate.size(); i++) {
            int number = numbersToCalculate.get(i);
            Future<Long> future = futures.get(i);
            try {
                // future.get() 会阻塞，直到该任务完成
                Long result = future.get(); // 可以设置超时: future.get(10, TimeUnit.SECONDS);
                System.out.println("Factorial of " + number + " is: " + result);
            } catch (InterruptedException e) {
                System.err.println("Main thread interrupted while waiting for factorial of " + number);
                Thread.currentThread().interrupt();
            } catch (ExecutionException e) {
                // ExecutionException 包装了 Callable.call() 方法中抛出的异常
                System.err.println("Error calculating factorial of " + number + ": " + e.getCause());
                // e.getCause() 获取原始异常 (例如 IllegalArgumentException)
            } catch (CancellationException e) {
                 // 如果任务被取消 (例如 future.cancel(true))
                 System.err.println("Factorial calculation for " + number + " was cancelled.");
            }
            // catch (TimeoutException e) {
            //     // 如果使用了带超时的 get()
            //     System.err.println("Timeout waiting for factorial of " + number);
            // }
        }

        // 关闭线程池
        System.out.println("Shutting down executor service...");
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(1, TimeUnit.MINUTES)) {
                 System.err.println("Pool did not terminate");
            }
        } catch (InterruptedException e) {
             executorService.shutdownNow();
            Thread.currentThread().interrupt();
        }

        System.out.println("Main thread finished.");
    }
}
```
Callable<V>：用于定义有返回值的异步任务，其 call() 方法替代 Runnable 的 run()，并且可以抛出受检异常。
Future<V>：代表异步计算的结果。executorService.submit(callable) 返回一个 Future 对象。
future.get()：用于获取计算结果。如果计算尚未完成，get() 会阻塞调用线程，直到结果可用。
它会抛出 InterruptedException（如果等待时被中断）和 ExecutionException（如果 call() 方法内部抛出异常）。
---

## 练习 14：使用 `CountDownLatch` 实现任务协调

*   **目标**：学习使用 `CountDownLatch` 让一个或多个线程等待其他一组线程完成特定操作。模拟主程序等待多个初始化子任务完成。
*   **要求**：
    1.  假设有 3 个初始化服务需要先完成，主程序才能继续执行。
    2.  在 `main` 方法中，创建一个 `CountDownLatch` 实例，计数器初始化为 3 (`CountDownLatch latch = new CountDownLatch(3);`)。
    3.  创建 3 个 `Runnable` 任务（可以使用 Lambda），分别代表 3 个初始化服务。
    4.  每个初始化服务的 `run` 方法：
        *   打印服务开始初始化的消息。
        *   模拟初始化耗时（`sleep` 随机时间）。
        *   打印服务初始化完成的消息。
        *   **关键**：在任务完成时调用 `latch.countDown()` 将计数器减 1。
    5.  使用 `ExecutorService` 或直接创建 `Thread` 启动这 3 个初始化任务。
    6.  主线程（`main`）在启动初始化任务后，调用 `latch.await()`。这将**阻塞主线程**，直到 `CountDownLatch` 的计数器变为 0（即所有 3 个初始化任务都调用了 `countDown()`）。
    7.  当 `latch.await()` 返回后，主线程打印 "所有初始化服务已完成，主程序继续执行..."。
    8.  （可选）可以创建一个服务失败的场景，例如某个服务抛出异常，不调用 `countDown()`，观察 `await()` 的行为（会一直等待或超时，如果使用带超时的 `await`）。

答案:
```java
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class Exercise14 {

    static class InitializationService implements Runnable {
        private final String serviceName;
        private final CountDownLatch latch;
        private final Random random = new Random();

        public InitializationService(String serviceName, CountDownLatch latch) {
            this.serviceName = serviceName;
            this.latch = latch;
        }

        @Override
        public void run() {
            try {
                 System.out.println("[" + serviceName + "] Initializing...");
                 // 模拟初始化耗时
                 TimeUnit.MILLISECONDS.sleep(1000 + random.nextInt(2000));
                 System.out.println("[" + serviceName + "] Initialization COMPLETE.");
            } catch (InterruptedException e) {
                 System.out.println("[" + serviceName + "] Initialization interrupted.");
                 Thread.currentThread().interrupt();
                 // 如果初始化失败，是否 countDown 取决于业务逻辑
                 // 这里假设中断也算完成（可能需要补偿），所以仍然 countDown
                 // 如果中断算失败，则不应 countDown
            } finally {
                 // 关键：无论成功还是（在此例中）中断，都减少 latch 计数
                 System.out.println("[" + serviceName + "] Counting down latch.");
                 latch.countDown();
            }
             // 模拟服务失败场景 (不 countDown)
             /*
             if (serviceName.equals("Service-2")) {
                 System.out.println("[" + serviceName + "] Initialization FAILED! Not counting down.");
                 // throw new RuntimeException("Init failed"); // 抛出异常
                 // 或者直接 return 不调用 countDown
             } else {
                 latch.countDown();
             }
             */
        }
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println("Main thread started (CountDownLatch version).");
        int numberOfServices = 3;
        CountDownLatch latch = new CountDownLatch(numberOfServices); // 初始化计数器为 3

        ExecutorService executor = Executors.newFixedThreadPool(numberOfServices);

        System.out.println("Starting initialization services...");
        executor.submit(new InitializationService("Service-1", latch));
        executor.submit(new InitializationService("Service-2", latch));
        executor.submit(new InitializationService("Service-3", latch));

        System.out.println("Main thread waiting for all services to initialize (latch.await())...");
        try {
            // 主线程阻塞，直到 latch 计数变为 0
            latch.await(); // 可以设置超时: latch.await(10, TimeUnit.SECONDS);
            System.out.println("All initialization services completed!");
            System.out.println("Main thread proceeding with main task...");
            // ... 执行主程序逻辑 ...
        } catch (InterruptedException e) {
             System.err.println("Main thread interrupted while waiting on latch.");
             Thread.currentThread().interrupt();
        }

        // 关闭线程池
        executor.shutdown();
        System.out.println("Main thread finished.");
    }
}
```
关键点：
- CountDownLatch(int count)：创建一个计数器初始值为 count 的同步辅助类。
- latch.await()：使当前线程等待，直到计数器归零，除非线程被中断。
- latch.countDown()：将计数器的值减 1。当计数达到 0 时，所有等待在 await() 上的线程都会被释放。
- CountDownLatch 是一次性的，计数器不能被重置。如果需要可重置的屏障，可以考虑 CyclicBarrier。
---

## 练习 15：使用 `AtomicInteger` 实现线程安全计数器

*   **目标**：使用 JUC 原子类 `AtomicInteger` 来替代 `synchronized` 实现线程安全的计数器，代码更简洁，通常性能更好（在高竞争下可能不一定）。
*   **要求**：
    1.  重构练习 6 的 `Counter` 类。
    2.  将 `private int count = 0;` 修改为 `private AtomicInteger count = new AtomicInteger(0);`。
    3.  修改 `increment()` 方法，不再需要 `synchronized`，直接调用 `count.incrementAndGet()` (或者 `count.getAndIncrement()`)。这个方法是原子操作。
    4.  修改 `getCount()` 方法，不再需要 `synchronized`，直接调用 `count.get()` 返回当前值。
    5.  `main` 方法和 `Runnable` 任务与练习 6 或 7 类似，使用这个新的 `AtomicCounter` 类。
    6.  运行程序，观察最终结果是否总是 100000。对比代码与练习 7 使用 `synchronized` 的版本。

答案:
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger; // 导入原子类

// 使用 AtomicInteger 的计数器
class AtomicCounter {
    // 使用 AtomicInteger 替代 int，初始值为 0
    private AtomicInteger count = new AtomicInteger(0);

    // incrementAndGet() 是原子操作
    public void increment() {
        count.incrementAndGet(); // 或者 getAndIncrement()
    }

    // get() 是原子操作
    public int getCount() {
        return count.get();
    }
}

public class Exercise15 {

    // Runnable 任务保持不变，只是现在操作 AtomicCounter
    static class IncrementTask implements Runnable {
        private AtomicCounter counter; // 使用原子计数器

        public IncrementTask(AtomicCounter counter) {
            this.counter = counter;
        }

        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
         System.out.println("Main thread started (AtomicInteger version).");
        AtomicCounter sharedCounter = new AtomicCounter(); // 使用原子计数器
        int numTasks = 10;
        int poolSize = 10; // 可以尝试不同的线程池大小

        ExecutorService executorService = Executors.newFixedThreadPool(poolSize);

        System.out.println("Submitting " + numTasks + " tasks...");
        for (int i = 0; i < numTasks; i++) {
            executorService.submit(new IncrementTask(sharedCounter));
        }

        executorService.shutdown();
        if (!executorService.awaitTermination(1, TimeUnit.MINUTES)) {
            System.err.println("Pool did not terminate");
        }

        System.out.println("All tasks completed.");
        System.out.println("Expected final count: 100000");
        System.out.println("Actual final count:   " + sharedCounter.getCount()); // 应该是 100000
        System.out.println("Main thread finished.");
    }
}
```
关键点：
AtomicInteger：java.util.concurrent.atomic 包下的类，提供了一种在多线程环境下对 int 值进行原子操作的方式。
incrementAndGet()：原子地将当前值加 1，并返回更新后的值。
get()：原子地读取当前值。
CAS (Compare-and-Swap)：AtomicInteger 等原子类的底层通常利用了 CPU 提供的 CAS 指令（或其他原子指令）来实现非阻塞的原子操作，这在高并发且竞争不极端的情况下，通常比使用 synchronized（涉及锁的获取和释放，可能导致线程阻塞）性能更好。代码也更简洁，因为不需要显式的 synchronized 关键字。