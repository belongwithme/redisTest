
redis是怎么删除过期key的?	Redis删除过期key采用了三种策略的混合：惰性删除、定期删除和主动删除。这种混合策略在内存占用和CPU使用之间取得了良好平衡。<br><br><b>惰性删除</b>：<br>只在必要时删除，不浪费CPU资源<br>缺点：如果大量key过期但未被访问，会占用大量内存,严重会导致内存泄漏<br><br><b>定期删除</b>：<br>Redis维护一个定时任务，周期性地抽样检查一部分过期key并删除它们。<br><b>执行策略</b>：<br>默认每100ms执行一次过期检查,每次检查会依次扫描所有数据库.<br>每个数据库中随机抽取20个带过期时间的key,删除其中已过期的key.<br>如果某个库中过期key比例超过25%，则重复步骤3-4，直到过期key比例低于25%或达到时间上限.<br><b>优点</b>：<br>通过控制删除频率和时间，平衡CPU和内存占用,避免长时间阻塞服务<br><b>缺点</b>：<br>难以确定最佳采样率和执行频率,然后也可能有部分过期key未被及时删除<br><br><b>主动删除</b>：<br>Redis还在特定场景下主动删除过期key：<br>- <b>写时删除</b>：当执行写操作(如SET)时，如果目标key已过期，Redis会先删除它再执行写入。<br>- <b>从库同步删除</b>：当主库因key过期而删除时，会向从库发送DEL命令，确保主从一致性。<br>- <b>RDB加载过滤</b>：在RDB加载过程中，Redis会过滤掉过期的key，避免将它们写入新的RDB文件。<br>- <b>AOF重写过滤</b>：执行AOF重写时，不会将已过期的key写入新的AOF文件。

Redis缓存过期的应用场景有哪些?	根据这个特点可以设置一些缓存策略:<br>- 热点数据(如考试配置)设置较长过期时间<br>- 临时数据(如验证码)设置短期过期时间

Redis提供了哪些内存淘汰策略?	Redis提供了8种内存淘汰策略，可以分为三大类：<br>- <b>不淘汰</b>：noeviction策略，内存不足时拒绝写入<br>- <b>针对设置了过期时间的键</b>：volatile系列，包括：<br>  - volatile-lru：淘汰最久未使用的<br>  - volatile-lfu：淘汰使用频率最低的<br>  - volatile-ttl：淘汰剩余生存时间最短的<br>  - volatile-random：随机淘汰<br>- <b>针对所有键</b>：allkeys系列，包括：<br>  - allkeys-lru：淘汰最久未使用的<br>  - allkeys-lfu：淘汰使用频率最低的<br>  - allkeys-random：随机淘汰

Redis内存淘汰策略的应用场景有哪些?	根据经验来看，选择合适的内存淘汰策略应考虑：<br>- <b>数据重要性</b>：核心业务数据考虑noeviction，防止意外丢失<br>- <b>访问模式</b>：<br>  - 明显热点数据选择LFU系列<br>  - 时间局部性强选择LRU系列<br>  - 时效性数据选择TTL系列<br>- <b>过期时间设置</b>：如果所有键都设置了合理的过期时间，volatile系列通常足够

Redis内存淘汰策略的记忆口诀是什么?	> "全域随近少，过期随近少时，拒绝不淘汰"<br>- <b>全域</b>：allkeys系列（针对所有键）<br>- <b>随近少</b>：random(随机)、LRU(最近)、LFU(最少)<br>- <b>过期</b>：volatile系列（针对过期键）<br>- <b>随近少时</b>：random、LRU、LFU、TTL(时间)<br>- <b>拒绝不淘汰</b>：noeviction

Redis内存回收是什么时候发起的?	内存回收有两种机制: 过期键删除和内存淘汰.<br>他们触发时机有一些差距.<br><b>过期键删除触发时机有两个</b>:<br>- 惰性删除当访问一个键时<br>- 定时删除在事件循环中,默认没100ms一次.<br><b>内存淘汰触发时机</b>:<br>- 主要是写命令执行前.<br>- 还有一些其他触发点:比如AOF重写,RDB保存等可能也会触发

经典LRU算法与Redis实现的差异是什么?	传统的LRU(Least Recently Used)算法通常使用双向链表+哈希表实现：<br>- 访问一个元素时，将其移到链表头部<br>- 需要淘汰时，移除链表尾部元素<br>- 哈希表用于O(1)时间定位元素<br>然而，Redis并没有采用这种标准实现，而是使用了一种近似LRU算法。这是因为：<br>- 标准LRU需要额外的链表指针，增加内存开销<br>- Redis已有的数据结构难以支持高效的链表移动操作<br>- 完美LRU在实际应用中并非必要

Redis为什么不使用标准LRU算法?	<b>内存开销分析</b>:<br>标准LRU算法需要维护一个双向链表，每个缓存对象都需要额外的前向和后向指针：<br>在64位系统上，每个指针占用8字节<br>一个对象需要两个指针(前向和后向)，共16字节<br>Redis中存储了数亿级别的键值对时，这些指针会占用大量内存<br>具体计算：<br>假设Redis存储1亿个键，标准LRU需要额外的内存：<br>1亿 × 16字节 ≈ 1.6GB 仅用于LRU链表指针(1个亿是10亿字节)<br>Redis的核心设计理念之一是高效利用内存,在这种设计理念下，为LRU额外增加16字节/键的开销被认为是不可接受的<br><br><b>Redis已有的数据结构难以支持高效的链表移动操作</b>:<br>Redis使用字典(dict)作为主要的数据结构来存储键值对：<br>- 哈希表的设计目标是快速查找，而非支持排序或顺序访问<br>- 哈希表中的元素位置由哈希函数决定，不便于维护访问顺序<br><br><b>完美LRU在实际应用中并非必要</b>:<br>近似LRU算法在实际应用中表现良好,采样数为10时，近似LRU的效果已接近理论LRU的99%.

Redis的近似LRU算法是如何实现的?	Redis的LRU算法基于随机采样：<br>1. 从键空间随机选择n个键(由maxmemory-samples配置，默认为5)<br>2. 比较这n个键的最后访问时间<br>3. 淘汰其中最久未使用的键<br><br><code>typedef struct redisObject {<br>    unsigned type:4;<br>    unsigned encoding:4;<br>    unsigned lru:24;  // LRU时间戳或LFU数据<br>    int refcount;<br>    void *ptr;<br>} robj;</code><br><br>这个时间戳记录了对象最后被访问的时间，精度为分钟级别。

Redis LRU算法中采样数量与精度的关系是什么?	maxmemory-samples参数直接影响LRU的精度:<br>- 默认值为5，是性能和精度的平衡点<br>- 增加到10可以使近似LRU非常接近理论LRU(约99%的精度)<br>- 但更高的采样数会增加CPU开销<br><br>Redis作者antirez的测试表明：<br>- 采样数=5时，近似LRU的命中率约为93%的理论LRU<br>- 采样数=10时，近似LRU的命中率约为99%的理论LRU<br><br>实际应用中的优化:<br>这就给了我们一些操作空间,我们可以根据不同场景去调整了LRU参数：<br>- 高流量缓存服务：<br>  - 增加采样数到10，提高LRU精度<br>  - 适用于内存有限但对性能要求不是极端的场景(因为CPU开销会增大)<br>- 读多写少的数据：<br>  - 保持默认采样数5<br>  - 在大多数缓存场景下表现良好

Redis LRU算法的时间戳更新机制是什么?	Redis不会在每次访问对象时都更新LRU时钟，而是采用一种概率更新策略：<br>- 默认情况下，每个对象被访问时有1/10的概率更新时间戳<br>- 这种策略减少了写操作，提高了性能<br>- 对LRU精度影响有限，因为分钟级精度已足够淘汰决策

Redis近似LRU算法有哪些缺点?	比较容易导致缓存污染,Redis2.8版本之前,Redis 2.8的LRU在采样数=5时，命中率仅约35%. <br>缓存污染的严重程度 - 有大量应该保留的热点数据被错误淘汰，而冷数据却占据了缓存空间。<br>我觉得主要因为:<br>- 完全随机采样，某些很久未被访问的键可能因为"运气好"而长期不被选中淘汰,假设有100万个键，但每次只采样5个<br>某个已经1个月未访问的"冷数据"，被选中的概率只有5/1,000,000<br>这个"幸运键"可能连续数千次淘汰过程都不被选中<br>同时，一些刚刚被访问过但"不幸"被选中的热点数据可能被淘汰,缓存中会积累大量实际上已经"冷"但侥幸存活的数据，这正是典型的缓存污染。<br>- 单次采样决策导致淘汰决策存在较大随机性：每次淘汰都是独立的,这种偏差会随着时间累积,使得缓存中"应该被淘汰"的键比例越来越高.

Redis 3.0后对LRU算法做了哪些改进?	Redis 3.0对LRU算法进行了显著改进：<br>引入了一个淘汰池(`eviction pool`)，保存候选淘汰对象<br>采样过程更加智能，不仅考虑当前采样结果，还参考之前的采样<br>淘汰池按空闲时间排序，优先淘汰空闲时间最长的对象<br>这些改进使得Redis的近似LRU更接近理论LRU，即使在较小的采样值下也有良好表现。

Redis中的"冷数据"是什么?	缓存系统中,"冷数据"指的是长时间未被访问或访问频率极低的数据,具体来说:<br>时间维度：长时间未被访问的数据（LRU角度）<br>频率维度：访问次数少的数据（LFU角度）<br>Redis的LRU实现主要关注时间维度，通过记录键的最后访问时间来判断数据的"冷热程度"。

Redis如何识别和淘汰最冷数据?	1.计算空闲时间,空闲时间越长，表示数据越"冷"，越应该被优先淘汰。<br>2.引入的淘汰池按照空闲时间对键进行排序，这是"优先淘汰最冷数据"策略的核心<br>3. 在evictionPoolPopulate方法中,拿到了空闲时间,有一个while循环,会按空闲时间进行降序排列<br>4. 池头部是最冷的数据,尾部是最热的数据<br>5. 选择淘汰池中的第一个键, 从数据库中删除该键,从淘汰池中移除该条目,直到内存足够.<br><br>有了这次更新,我们能够在有限的内存资源下，最大化缓存的效益，同时保持系统的高性能和稳定性。

什么是LFU算法,为什么Redis要引入LFU算法?	LFU(Least Frequently Used)算法是一种缓存淘汰策略，它基于使用频率来决定淘汰哪些数据。核心思想是：淘汰访问次数最少的数据项。<br><br><b>基本原因</b>:<br>为每个缓存项维护一个访问频率计数器,每当数据被访问时，增加其计数器值,需要淘汰时，移除计数器值最小的数据项.<br><br><b>为什么引入LFU算法</b>:<br>LRU算法存在一个根本性缺陷：它只考虑时间因素，忽略了访问频率。<br>这导致以下问题:<br>- <b>突发访问问题</b>:<br>想象一个每5分钟访问一次的重要键，和一个突然被访问100次但再也不会被访问的键。LRU会淘汰重要的键而保留不再需要的键.<br>这显然不合理，因为数据A是稳定的热点数据，而数据B只是临时热点。<br>- <b>不能适应更复杂的访问模式</b>:<br>  - 现代应用的数据访问模式越来越复杂：<br>    - 长尾分布：少量数据被频繁访问，大量数据被偶尔访问<br>    - 突发访问：数据短时间内被大量访问，然后长时间不再访问<br>    - 周期性访问：数据按固定时间间隔被访问

Redis如何实现LFU算法?	实现非常巧妙，它重用了原有的24位LRU字段，将其分为两部分：<br>-上次递减时间(Last Decr)：用于实现计数器的衰减,防止历史热点永远占据缓存;16位<br>-计数器(Counter)：记录访问频率，计数器不是线性增加的，而是概率递增，递增概率随着计数值增大而减小;8位，最大值255<br><br> 16 bits      8 bits<br>+------------+--------+<br>| Last Decr  | Counter |<br>+------------+--------+

LFU算法有哪些局限性?	尽管LFU有诸多优势，但它也有一些局限性：<br>1. 冷启动问题：新加入的数据初始频率为0，需要时间积累才能与老数据竞争<br>2. 内存开销：需要为每个键维护额外的计数器(不过Redis通过复用LRU字段巧妙解决了这个问题)<br>3. 参数调优：LFU的效果受lfu-log-factor和lfu-decay-time参数影响，需要根据实际工作负载调优.

如何选择LRU还是LFU?	Redis提供了LRU和LFU两种策略，如何选择取决于您的应用场景：<br><b>适合使用LRU的场景</b>:<br>- 访问模式具有强时间局部性<br>- 最近访问的数据很可能再次被访问<br>- 所有数据的重要性相近<br><b>适合使用LFU的场景</b>:<br>- 访问频率差异明显<br>- 有明确的数据访问偏好<br>- 存在周期性访问的重要数据<br>- 需要区分临时热点和持久热点

以上就是将Redis缓存过期和内存淘汰文档转换为Anki卡片格式的结果。每个卡片都使用制表符分隔问题和答案，并使用HTML标签处理格式和换行。这些卡片可以直接导入到Anki中，并且会保持原文的所有重点和细节。
