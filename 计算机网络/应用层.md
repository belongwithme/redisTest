@[toc](应用层)

# HTTP
## HTTP协议的特点是什么？
个人版本回答：
首先，它是无状态的，这意味着服务器不会在多个请求之间保存客户端信息。这种设计使服务器能够高效处理并发请求，但也带来了session管理的挑战。
其次，HTTP是文本协议，使用人类可读的格式进行通信，这使得调试和开发非常方便。但这也导致了协议报文有较大的开销，HTTP/2和HTTP/3通过二进制格式改进了这一点。
HTTP的无连接特性在早期版本中尤为明显，HTTP/1.0每个请求都需要建立新的TCP连接。虽然HTTP/1.1引入了持久连接，但协议本身的设计理念仍是请求-响应模式，不适合推送类应用场景。
HTTP协议可扩展性强，通过首部字段轻松扩展功能，如缓存控制、认证、内容协商等。这种设计使它能够适应互联网发展中的各种需求变化。
最后，HTTP建立在TCP之上，这种选择保证了通信的可靠性，但也继承了TCP的一些问题，比如队头阻塞。
## HTTP 报文格式？怎么分割的？
对于请求报文，核心部分是请求行，它定义了"意图"（HTTP方法）、"资源"（URL）和"规则版本"（HTTP版本）。它告诉服务器"我想对什么资源做什么操作"。
对于响应报文，核心是状态行，它包含了"规则版本"和"结果代码"（状态码及描述），简洁地表达了请求处理的结果。
两种报文都包含头部字段，这是HTTP可扩展性的关键。头部采用键值对设计，允许在不破坏协议结构的情况下添加新功能。从协议设计角度看，这种扩展机制非常优雅。
报文分割采用了明确的分隔符机制：CRLF（\r\n）用于行分隔，空行（两个CRLF）用于区分头部和主体。这种基于文本的分割方式使得报文易于人类阅读，但也增加了解析的复杂性和传输的开销。
HTTP/2和HTTP/3改变了这种文本格式，采用二进制帧结构，但逻辑上仍保持了相同的组织方式，证明了这种格式设计的合理性和可进化性。
## HTTP默认的端口是什么？
HTTP选择80作为默认端口.
## HTTP 有什么方法？
HTTP方法本质上是对资源操作的语义化定义，反映了HTTP协议的设计理念。
从REST架构风格来看，这些方法形成了一套完整的资源操作语义：
- GET方法体现了"读取"语义，设计上不应改变资源状态，符合分布式系统中安全操作的概念
- POST方法表示"创建"或"处理"，它的设计最为灵活，但也容易被滥用
- PUT和DELETE方法分别对应"完全替换"和"删除"操作，使API具有直观的语义
从协议演进角度，早期HTTP主要使用GET和POST，而随着REST架构的流行，PUT、DELETE等方法得到更广泛应用。这反映了Web从"文档传输"向"应用平台"的转变。
从安全角度，不同方法有不同的安全特性:
- HEAD和OPTIONS等方法主要用于元数据操作，提供了在不传输完整资源的情况下进行通信的能力。
- CONNECT方法则专为安全隧道设计，在HTTPS代理中扮演关键角色。
- PATCH方法是后来加入的，它解决了PUT方法的一个局限 - 无法进行部分更新。这展示了HTTP协议如何根据实际需求不断完善其语义体系。
## 分析一下哪些HTTP方法是安全或幂等的？
安全性和幂等性是理解HTTP方法语义的两个核心概念，它们反映了分布式系统设计中的重要原则。
安全性指的是方法不应该有副作用，即不改变服务器资源状态。这一概念源自分布式系统中对只读操作的区分。GET、HEAD、OPTIONS和TRACE方法被设计为安全的，这使得这些操作可以被缓存、预取.
幂等性则是分布式系统处理失败重试的基础 - 当操作可能因网络问题需要重试时，幂等操作可以安全地重复执行而不产生额外影响。PUT和DELETE是典型的幂等方法 - 多次替换同一资源的效果与一次相同，多次删除已删除的资源也不会有额外影响。
## GET 和 POST 请求的区别？追问：GET 请求一定是安全且幂等的吗？
GET和POST的区别反映了HTTP协议设计中对不同操作语义的抽象。
从协议语义角度，GET设计用于获取资源，而POST用于提交数据以触发状态变化。
如果开发者遵循规范去处理请求,那就是安全且幂等的.
但是如何开发者处理get请求的方式是新增数据,这时候GET请求就不是安全且幂等的.
比如我在一个get 方法里插入一个数据库记录,这时候GET请求就不是安全且幂等的.

## HTTP 有什么状态码？
HTTP状态码是协议设计中对请求处理结果的抽象和分类，它们形成了一种简洁有效的通信机制。
从架构角度，状态码的分类反映了Web系统的关注点分离：
1xx：反映了HTTP协议的交互机制，如100 Continue允许客户端分阶段发送请求，这对处理大型上传很有用
2xx：表示正常流程的各种场景，如200 OK表示成功，201 Created表示资源创建，206 Partial Content支持断点续传
3xx：处理资源定位变化，如301永久重定向和302临时重定向，这是Web资源管理的重要机制
4xx：表示客户端错误，如400表示请求格式错误，401需要身份验证，403表示权限不足，404表示资源不存在
5xx：表示服务端错误，如500内部错误，503服务不可用
从系统设计角度，这种分类既是通信协议，也是错误处理机制。客户端可以根据状态码大类判断错误归属并采取相应的恢复策略。例如，面对4xx错误，客户端应修改请求；面对5xx错误，可能需要重试或降级处理。
从开发实践看，状态码使得API设计更加规范化，也便于监控和调试。例如，监控系统可以根据状态码分布判断系统健康状况，日志分析可以根据状态码识别异常模式。
状态码的设计充分体现了HTTP协议"简单但可扩展"的设计理念，在简明扼要地传达信息的同时，也为特定应用场景预留了定制空间。
## 什么情况下会出现502错误码呢？
502 Bad Gateway 错误本质上是一个"中间人"告诉你"我联系后端服务时出了问题"。
在典型的Web架构中，客户端请求首先到达的往往是反向代理层（如Nginx、HAProxy），然后才转发到实际处理业务逻辑的应用服务器。502错误正是这个代理层报告的"我无法正确获取或解析来自后端的响应"。
常见的502场景包括：
- 应用服务宕机：代理尝试连接应用服务器但连接被拒绝
- 通信协议不匹配：例如代理配置为HTTP但应用服务使用了HTTPS
- 响应头格式错误：应用服务器返回了不符合HTTP规范的响应
- 应用服务异常退出：在处理请求过程中崩溃，导致连接突然关闭
## 有个服务出现了504，你觉得这个服务器遇到了什么问题？
从根因分析角度，504通常可以追溯到以下几类问题：
- 处理时间过长：后端服务需要执行耗时操作，如复杂查询、大数据处理或外部API调用。这反映了系统设计中可能存在的计算密集型操作未被适当优化或异步化。
- 资源竞争：后端服务面临资源争用，如数据库连接池耗尽、线程池饱和或内存压力大。这通常是系统在高并发场景下的容量问题。
- 配置不匹配：代理层的超时设置与后端处理时间不匹配。例如，如果Nginx配置了10秒超时，但后端操作需要15秒，就会出现504。
## 重定向是哪一类状态码？临时重定向和永久重定向有什么区别？
重定向状态码（3xx系列）体现了HTTP协议对资源位置变化的处理机制。从Web架构角度，重定向是实现资源定位灵活性的关键机制。
从信息论角度，重定向本质上是一种"间接寻址"：告诉客户端"你要找的东西不在这里，去那里找"。3xx状态码正是这种寻址重定向的语义编码。
永久重定向（301、308）和临时重定向（302、303、307）的核心区别在于资源位置变化的持久性：
永久重定向表示资源已经永久移动到新位置。这种语义有几个重要影响：
- 客户端被鼓励更新书签
- 浏览器会缓存这个重定向结果，后续直接访问新地址
- 搜索引擎会将索引从旧地址迁移到新地址，传递链接权重
临时重定向表示资源只是暂时位于其他位置。其影响是：
- 客户端不应更新书签
- 浏览器每次仍会先访问原地址
- 搜索引擎维持原地址的索引
## HTTP是长连接还是短连接？

## HTTP长连接和短连接的区别？

## HTTP长连接有什么好处？
## HTTP/1.0 和 HTTP/1.1 的区别？
## HTTP/1.1 和 HTTP/2.0 的区别？
## HTTP/2.0 和 HTTP/3.0 的区别？
## HTTP是无状态的吗？
## HTTP 用户后续的操作，服务端如何知道属于同一个用户？追问：如果服务端是一个集群机器？
## 如果禁用 Cookie，怎么实现 Session？
## cookie 和 session 的区别？
## Cookie、Session 和 Token 有什么区别？
## 简述 JWT 的原理和校验机制
## JWT 令牌为什么能够实集群共享？
## JWT 有什么缺点？
## 什么是跨域？什么情况下会发生跨域请求？
## RestFul 是什么？RestFul 请求的 URL 有什么特点？
